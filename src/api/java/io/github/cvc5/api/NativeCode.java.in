/******************************************************************************
 * Modified version of
 * https://github.com/AlloyTools/org.alloytools.alloy/blob/master/org.alloytools.kodkod.nativesat/src/main/java/org/alloytools/nativecode/util/NativeCode.java
 * with license
 * https://github.com/AlloyTools/org.alloytools.alloy/blob/master/LICENSE
 * ****************************************************************************
 *
 * The cvc5 java API.
 */

package io.github.cvc5.api;

import java.io.*;
import java.net.URISyntaxException;
import java.net.URL;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.List;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

/**
 * class for loading native libraries
 */
public class NativeCode
{
  /** names of native libraries */
  static String[] jniLibraries = new String[] {"cvc5jni"};

  /** cvc5 version */
  public static final String version = "${CVC5_VERSION}";

  /** cvc5 name */
  public static final String homeName = "cvc5";

  /**
   * This variable caches the result of home() function call.
   */
  private static String home = null;

  /**
   * The system-specific file separator (/ or \)
   */
  private static final char fs = File.separatorChar;

  /**
   * Find a temporary directory to store cvc5 files; it's guaranteed to be a
   * canonical absolute path.
   */
  private static synchronized String home()
  {
    if (home != null)
    {
      return home;
    }
    else
    {
      String tmpPath = System.getProperty("java.io.tmpdir");
      if (tmpPath == null || tmpPath.length() == 0)
      {
        System.out.println(
                "Error. JVM need to specify a temporary directory using java.io.tmpdir property.");
      }
      // e.g. /tmp/cvc5/0.0.0/amd64-linux
      String tmp = tmpPath + fs + homeName + fs + version + fs + platform.dir;
      File tmpDirectory = new File(tmp);
      tmpDirectory.mkdirs();
      home = tmpDirectory.getAbsolutePath();
    }
    System.out.println("cvc5 home: " + home);
    System.setProperty("java.library.path", home());
    return home;
  }

  /**
   * Copy libraries from the jar file to cvc5 home directory
   */
  static void copyLibraries()
  {
    try
    {
      InputStream inputStream = NativeCode.class.getClassLoader().getResourceAsStream(platform.dir);
      if (inputStream == null)
      {
        throw new RuntimeException("Could not find resource " + platform.dir);
      }
      List<String> files = new BufferedReader(
            new InputStreamReader(inputStream, StandardCharsets.UTF_8)) .lines().collect(Collectors.toList());
      String prefix = home() + fs;
      for (String file : files)
      {
        InputStream fileStream = NativeCode.class.getClassLoader().getResourceAsStream(platform.dir + "/" + file);
        String destination = prefix + file;
        Files.copy(fileStream, Paths.get(destination), StandardCopyOption.REPLACE_EXISTING);
      }
      Runtime.getRuntime().exec("ln -s " + prefix + "libcvc5.so.1 " + prefix + "libcvc5.so");
      Runtime.getRuntime().exec("ln -s " + prefix + "libpoly.so.0.1.9 " + prefix + "libpoly.so.0");
      Runtime.getRuntime().exec("ln -s " + prefix + "libpolyxx.so.0.1.9 " + prefix + "libpolyxx.so.0");
      Runtime.getRuntime().exec("ln -s " + prefix + "libpoly.so.0 " + prefix + "libpoly.so");
      Runtime.getRuntime().exec("ln -s " + prefix + "libpolyxx.so.0 " + prefix + "libpolyxx.so");
    }
    catch (Exception e)
    {
      throw new RuntimeException(e);
    }
  }

  /** load jni library with the given name */
  public static void loadLibrary(String name) throws RuntimeException
  {
    try
    {
      String libraryName = System.mapLibraryName(name);
      String libraryPath = home() + fs + libraryName;
      System.load(libraryPath);
    }
    catch (Exception e)
    {
      throw new RuntimeException(e);
    }
  }

  /** Load jni libraries */
  public static void loadLibraries()
  {
    copyLibraries();
    for (String name : jniLibraries)
    {
      NativeCode.loadLibrary(name);
    }
  }

  static class Platform
  {
    public Platform(String osnames, String osarch, String dir)
    {
      try
      {
        this.osarch = Pattern.compile(osarch, Pattern.CASE_INSENSITIVE);
        this.osname = Pattern.compile(osnames, Pattern.CASE_INSENSITIVE);
        this.dir = dir;
      }
      catch (Exception e)
      {
        e.printStackTrace();
        throw new RuntimeException(e);
      }
    }

    final Pattern osname;
    final Pattern osarch;
    final String dir;
  }

  public static Platform AMD64_LINUX = new Platform("linux", "amd64", "amd64-linux");
  public static Platform X86_LINUX = new Platform("linux", ".*86.*", "x86-linux");
  public static Platform X86_MAC =
          new Platform("mac\\s*os.*", "ppc|power|powerpc.*|x86.*", "x86-mac");
  public static Platform X86_WINDOWS = new Platform("win.*", "x86.*", "x86-windows");
  public static Platform[] platforms = {AMD64_LINUX, X86_LINUX, X86_MAC, X86_WINDOWS};

  public static Platform platform = findPlatform();

  private static Platform findPlatform()
  {
    String os = System.getProperty("os.name");
    String arch = System.getProperty("os.arch");
    for (Platform p : platforms)
    {
      if (p.osarch.matcher(arch).matches() && p.osname.matcher(os).matches())
      {
        System.out.println("arch-os: " + p.dir);
        return platform = p;
      }
    }
    return new Platform(".*", ".*", null);
  }
}
