(include "../theories/Arith.smt3")

(program arith_eval_mixed_plus ((U Type) (T Type) (S Type) (x T) (ys S :list))
  (U) (@Pair U Type)
  (
    ((arith_eval_mixed_plus (+ x ys))
      (let ((xq (alf.to_q x)))
      (alf.match ((R Type) (z S))
        (arith_eval_mixed_plus ys)
        ((@pair z R)  (alf.ite (alf.is_eq R Real)
                         (@pair (alf.add z xq) Real)
                         (alf.ite (alf.is_eq x xq)
                           (@pair (alf.add (alf.to_q z) xq) Real)
                           (@pair (alf.add z x) Int)))))))
    ((arith_eval_mixed_plus 0) (@pair 0 Int))
  )
)

(define arith_eval_plus ((T Type :implicit) (x T))
  (alf.match ((S Type) (y S)) 
    (arith_eval_mixed_plus x)
    ((@pair y S) y)
  )
)

(define arith_eval_sub ((U Type :implicit) (T Type :implicit) (x U) (y T))
  (arith_eval_plus (+ x (alf.neg y))))

; Evaluates the difference (- x y) as a rational.
; Note this returns a rational value even if x and y are numeral values.
(define arith_eval_qsub ((U Type :implicit) (T Type :implicit) (x U) (y T))
  (alf.add (alf.to_q x) (alf.neg (alf.to_q y))))


