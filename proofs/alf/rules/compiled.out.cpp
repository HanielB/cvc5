/** ================ AUTO GENERATED ============ */
#include "state.h"
#include "type_checker.h"

namespace alfc {

AttrMap _amap;
std::map<ExprValue*, size_t> _runId;
Ctx _ctxTmp;
Expr _etmp;
  Expr _e1;
  Expr _e2;
  Expr _e3;
  Expr _e4;
  Expr _e5;
  Expr _e6;
  Expr _e7;
  Expr _e8;
  Expr _e9;
  Expr _e10;
  Expr _e11;
  Expr _e12;
  Expr _e13;
  Expr _e14;
  Expr _e15;
  Expr _e16;
  Expr _e17;
  Expr _e18;
  Expr _e19;
  Expr _e20;
  Expr _e21;
  Expr _e22;
  Expr _e23;
  Expr _e24;
  Expr _e25;
  Expr _e26;
  Expr _e27;
  Expr _e28;
  Expr _e29;
  Expr _e30;
  Expr _e31;
  Expr _e32;
  Expr _e33;
  Expr _e34;
  Expr _e35;
  Expr _e36;
  Expr _e37;
  Expr _e38;
  Expr _e39;
  Expr _e40;
  Expr _e41;
  Expr _e42;
  Expr _e43;
  Expr _e44;
  Expr _e45;
  Expr _e46;
  Expr _e47;
  Expr _e48;
  Expr _e49;
  Expr _e50;
  Expr _e51;
  Expr _e52;
  Expr _e53;
  Expr _e54;
  Expr _e55;
  Expr _e56;
  Expr _e57;
  Expr _e58;
  Expr _e59;
  Expr _e60;
  Expr _e61;
  Expr _e62;
  Expr _e63;
  Expr _e64;
  Expr _e65;
  Expr _e66;
  Expr _e67;
  Expr _e68;
  Expr _e69;
  Expr _e70;
  Expr _e71;
  Expr _e72;
  Expr _e73;
  Expr _e74;
  Expr _e75;
  Expr _e76;
  Expr _e77;
  Expr _e78;
  Expr _e79;
  Expr _e80;
  Expr _e81;
  Expr _e82;
  Expr _e83;
  Expr _e84;
  Expr _e85;
  Expr _e86;
  Expr _e87;
  Expr _e88;
  Expr _e89;
  Expr _e90;
  Expr _e91;
  Expr _e92;
  Expr _e93;
  Expr _e94;
  Expr _e95;
  Expr _e96;
  Expr _e97;
  Expr _e98;
  Expr _e99;
  Expr _e100;
  Expr _e101;
  Expr _e102;
  Expr _e103;
  Expr _e104;
  Expr _e105;
  Expr _e106;
  Expr _e107;
  Expr _e108;
  Expr _e109;
  Expr _e110;
  Expr _e111;
  Expr _e112;
  Expr _e113;
  Expr _e114;
  Expr _e115;
  Expr _e116;
  Expr _e117;
  Expr _e118;
  Expr _e119;
  Expr _e120;
  Expr _e121;
  Expr _e122;
  Expr _e123;
  Expr _e124;
  Expr _e125;
  Expr _e126;
  Expr _e127;
  Expr _e128;
  Expr _e129;
  Expr _e130;
  Expr _e131;
  Expr _e132;
  Expr _e133;
  Expr _e134;
  Expr _e135;
  Expr _e136;
  Expr _e137;
  Expr _e138;
  Expr _e139;
  Expr _e140;
  Expr _e141;
  Expr _e142;
  Expr _e143;
  Expr _e144;
  Expr _e145;
  Expr _e146;
  Expr _e147;
  Expr _e148;
  Expr _e149;
  Expr _e150;
  Expr _e151;
  Expr _e152;
  Expr _e153;
  Expr _e154;
  Expr _e155;
  Expr _e156;
  Expr _e157;
  Expr _e158;
  Expr _e159;
  Expr _e160;
  Expr _e161;
  Expr _e162;
  Expr _e163;
  Expr _e164;
  Expr _e165;
  Expr _e166;
  Expr _e167;
  Expr _e168;
  Expr _e169;
  Expr _e170;
  Expr _e171;
  Expr _e172;
  Expr _e173;
  Expr _e174;
  Expr _e175;
  Expr _e176;
  Expr _e177;
  Expr _e178;
  Expr _e179;
  Expr _e180;
  Expr _e181;
  Expr _e182;
  Expr _e183;
  Expr _e184;
  Expr _e185;
  Expr _e186;
  Expr _e187;
  Expr _e188;
  Expr _e189;
  Expr _e190;
  Expr _e191;
  Expr _e192;
  Expr _e193;
  Expr _e194;
  Expr _e195;
  Expr _e196;
  Expr _e197;
  Expr _e198;
  Expr _e199;
  Expr _e200;
  Expr _e201;
  Expr _e202;
  Expr _e203;
  Expr _e204;
  Expr _e205;
  Expr _e206;
  Expr _e207;
  Expr _e208;
  Expr _e209;
  Expr _e210;
  Expr _e211;
  Expr _e212;
  Expr _e213;
  Expr _e214;
  Expr _e215;
  Expr _e216;
  Expr _e217;
  Expr _e218;
  Expr _e219;
  Expr _e220;
  Expr _e221;
  Expr _e222;
  Expr _e223;
  Expr _e224;
  Expr _e225;
  Expr _e226;
  Expr _e227;
  Expr _e228;
  Expr _e229;
  Expr _e230;
  Expr _e231;
  Expr _e232;
  Expr _e233;
  Expr _e234;
  Expr _e235;
  Expr _e236;
  Expr _e237;
  Expr _e238;
  Expr _e239;
  Expr _e240;
  Expr _e241;
  Expr _e242;
  Expr _e243;
  Expr _e244;
  Expr _e245;
  Expr _e246;
  Expr _e247;
  Expr _e248;
  Expr _e249;
  Expr _e250;
  Expr _e251;
  Expr _e252;
  Expr _e253;
  Expr _e254;
  Expr _e255;
  Expr _e256;
  Expr _e257;
  Expr _e258;
  Expr _e259;
  Expr _e260;
  Expr _e261;
  Expr _e262;
  Expr _e263;
  Expr _e264;
  Expr _e265;
  Expr _e266;
  Expr _e267;
  Expr _e268;
  Expr _e269;
  Expr _e270;
  Expr _e271;
  Expr _e272;
  Expr _e273;
  Expr _e274;
  Expr _e275;
  Expr _e276;
  Expr _e277;
  Expr _e278;
  Expr _e279;
  Expr _e280;
  Expr _e281;
  Expr _e282;
  Expr _e283;
  Expr _e284;
  Expr _e285;
  Expr _e286;
  Expr _e287;
  Expr _e288;
  Expr _e289;
  Expr _e290;
  Expr _e291;
  Expr _e292;
  Expr _e293;
  Expr _e294;
  Expr _e295;
  Expr _e296;
  Expr _e297;
  Expr _e298;
  Expr _e299;
  Expr _e300;
  Expr _e301;
  Expr _e302;
  Expr _e303;
  Expr _e304;
  Expr _e305;
  Expr _e306;
  Expr _e307;
  Expr _e308;
  Expr _e309;
  Expr _e310;
  Expr _e311;
  Expr _e312;
  Expr _e313;
  Expr _e314;
  Expr _e315;
  Expr _e316;
  Expr _e317;
  Expr _e318;
  Expr _e319;
  Expr _e320;
  Expr _e321;
  Expr _e322;
  Expr _e323;
  Expr _e324;
  Expr _e325;
  Expr _e326;
  Expr _e327;
  Expr _e328;
  Expr _e329;
  Expr _e330;
  Expr _e331;
  Expr _e332;
  Expr _e333;
  Expr _e334;
  Expr _e335;
  Expr _e336;
  Expr _e337;
  Expr _e338;
  Expr _e339;
  Expr _e340;
  Expr _e341;
  Expr _e342;
  Expr _e343;
  Expr _e344;
  Expr _e345;
  Expr _e346;
  Expr _e347;
  Expr _e348;
  Expr _e349;
  Expr _e350;
  Expr _e351;
  Expr _e352;
  Expr _e353;
  Expr _e354;
  Expr _e355;
  Expr _e356;
  Expr _e357;
  Expr _e358;
  Expr _e359;
  Expr _e360;
  Expr _e361;
  Expr _e362;
  Expr _e363;
  Expr _e364;
  Expr _e365;
  Expr _e366;
  Expr _e367;
  Expr _e368;
  Expr _e369;
  Expr _e370;
  Expr _e371;
  Expr _e372;
  Expr _e373;
  Expr _e374;
  Expr _e375;
  Expr _e376;
  Expr _e377;
  Expr _e378;
  Expr _e379;
  Expr _e380;
  Expr _e381;
  Expr _e382;
  Expr _e383;
  Expr _e384;
  Expr _e385;
  Expr _e386;
  Expr _e387;
  Expr _e388;
  Expr _e389;
  Expr _e390;
  Expr _e391;
  Expr _e392;
  Expr _e393;
  Expr _e394;
  Expr _e395;
  Expr _e396;
  Expr _e397;
  Expr _e398;
  Expr _e399;
  Expr _e400;
  Expr _e401;
  Expr _e402;
  Expr _e403;
  Expr _e404;
  Expr _e405;
  Expr _e406;
  Expr _e407;
  Expr _e408;
  Expr _e409;
  Expr _e410;
  Expr _e411;
  Expr _e412;
  Expr _e413;
  Expr _e414;
  Expr _e415;
  Expr _e416;
  Expr _e417;
  Expr _e418;
  Expr _e419;
  Expr _e420;
  Expr _e421;
  Expr _e422;
  Expr _e423;
  Expr _e424;
  Expr _e425;
  Expr _e426;
  Expr _e427;
  Expr _e428;
  Expr _e429;
  Expr _e430;
  Expr _e431;
  Expr _e432;
  Expr _e433;
  Expr _e434;
  Expr _e435;
  Expr _e436;
  Expr _e437;
  Expr _e438;
  Expr _e439;
  Expr _e440;
  Expr _e441;
  Expr _e442;
  Expr _e443;
  Expr _e444;
  Expr _e445;
  Expr _e446;
  Expr _e447;
  Expr _e448;
  Expr _e449;
  Expr _e450;
  Expr _e451;
  Expr _e452;
  Expr _e453;
  Expr _e454;
  Expr _e455;
  Expr _e456;
  Expr _e457;
  Expr _e458;
  Expr _e459;
  Expr _e460;
  Expr _e461;
  Expr _e462;
  Expr _e463;
  Expr _e464;
  Expr _e465;
  Expr _e466;
  Expr _e467;
  Expr _e468;
  Expr _e469;
  Expr _e470;
  Expr _e471;
  Expr _e472;
  Expr _e473;
  Expr _e474;
  Expr _e475;
  Expr _e476;
  Expr _e477;
  Expr _e478;
  Expr _e479;
  Expr _e480;
  Expr _e481;
  Expr _e482;
  Expr _e483;
  Expr _e484;
  Expr _e485;
  Expr _e486;
  Expr _e487;
  Expr _e488;
  Expr _e489;
  Expr _e490;
  Expr _e491;
  Expr _e492;
  Expr _e493;
  Expr _e494;
  Expr _e495;
  Expr _e496;
  Expr _e497;
  Expr _e498;
  Expr _e499;
  Expr _e500;
  Expr _e501;
  Expr _e502;
  Expr _e503;
  Expr _e504;
  Expr _e505;
  Expr _e506;
  Expr _e507;
  Expr _e508;
  Expr _e509;
  Expr _e510;
  Expr _e511;
  Expr _e512;
  Expr _e513;
  Expr _e514;
  Expr _e515;
  Expr _e516;
  Expr _e517;
  Expr _e518;
  Expr _e519;
  Expr _e520;
  Expr _e521;
  Expr _e522;
  Expr _e523;
  Expr _e524;
  Expr _e525;
  Expr _e526;
  Expr _e527;
  Expr _e528;
  Expr _e529;
  Expr _e530;
  Expr _e531;
  Expr _e532;
  Expr _e533;
  Expr _e534;
  Expr _e535;
  Expr _e536;
  Expr _e537;
  Expr _e538;
  Expr _e539;
  Expr _e540;
  Expr _e541;
  Expr _e542;
  Expr _e543;
  Expr _e544;
  Expr _e545;
  Expr _e546;
  Expr _e547;
  Expr _e548;
  Expr _e549;
  Expr _e550;
  Expr _e551;
  Expr _e552;
  Expr _e553;
  Expr _e554;
  Expr _e555;
  Expr _e556;
  Expr _e557;
  Expr _e558;
  Expr _e559;
  Expr _e560;
  Expr _e561;
  Expr _e562;
  Expr _e563;
  Expr _e564;
  Expr _e565;
  Expr _e566;
  Expr _e567;
  Expr _e568;
  Expr _e569;
  Expr _e570;
  Expr _e571;
  Expr _e572;
  Expr _e573;
  Expr _e574;
  Expr _e575;
  Expr _e576;
  Expr _e577;
  Expr _e578;
  Expr _e579;
  Expr _e580;
  Expr _e581;
  Expr _e582;
  Expr _e583;
  Expr _e584;
  Expr _e585;
  Expr _e586;
  Expr _e587;
  Expr _e588;
  Expr _e589;
  Expr _e590;
  Expr _e591;
  Expr _e592;
  Expr _e593;
  Expr _e594;
  Expr _e595;
  Expr _e596;
  Expr _e597;
  Expr _e598;
  Expr _e599;
  Expr _e600;
  Expr _e601;
  Expr _e602;
  Expr _e603;
  Expr _e604;
  Expr _e605;
  Expr _e606;
  Expr _e607;
  Expr _e608;
  Expr _e609;
  Expr _e610;
  Expr _e611;
  Expr _e612;
  Expr _e613;
  Expr _e614;
  Expr _e615;
  Expr _e616;
  Expr _e617;
  Expr _e618;
  Expr _e619;
  Expr _e620;
  Expr _e621;
  Expr _e622;
  Expr _e623;
  Expr _e624;
  Expr _e625;
  Expr _e626;
  Expr _e627;
  Expr _e628;
  Expr _e629;
  Expr _e630;
  Expr _e631;
  Expr _e632;
  Expr _e633;
  Expr _e634;
  Expr _e635;
  Expr _e636;
  Expr _e637;
  Expr _e638;
  Expr _e639;
  Expr _e640;
  Expr _e641;
  Expr _e642;
  Expr _e643;
  Expr _e644;
  Expr _e645;
  Expr _e646;
  Expr _e647;
  Expr _e648;
  Expr _e649;
  Expr _e650;
  Expr _e651;
  Expr _e652;
  Expr _e653;
  Expr _e654;
  Expr _e655;
  Expr _e656;
  Expr _e657;
  Expr _e658;
  Expr _e659;
  Expr _e660;
  Expr _e661;
  Expr _e662;
  Expr _e663;
  Expr _e664;
  Expr _e665;
  Expr _e666;
  Expr _e667;
  Expr _e668;
  Expr _e669;
  Expr _e670;
  Expr _e671;
  Expr _e672;
  Expr _e673;
  Expr _e674;
  Expr _e675;
  Expr _e676;
  Expr _e677;
  Expr _e678;
  Expr _e679;
  Expr _e680;
  Expr _e681;
  Expr _e682;
  Expr _e683;
  Expr _e684;
  Expr _e685;
  Expr _e686;
  Expr _e687;
  Expr _e688;
  Expr _e689;
  Expr _e690;
  Expr _e691;
  Expr _e692;
  Expr _e693;
  Expr _e694;
  Expr _e695;
  Expr _e696;
  Expr _e697;
  Expr _e698;
  Expr _e699;
  Expr _e700;
  Expr _e701;
  Expr _e702;
  Expr _e703;
  Expr _e704;
  Expr _e705;
  Expr _e706;
  Expr _e707;
  Expr _e708;
  Expr _e709;
  Expr _e710;
  Expr _e711;
  Expr _e712;
  Expr _e713;
  Expr _e714;
  Expr _e715;
  Expr _e716;
  Expr _e717;
  Expr _e718;
  Expr _e719;
  Expr _e720;
  Expr _e721;
  Expr _e722;
  Expr _e723;
  Expr _e724;
  Expr _e725;
  Expr _e726;
  Expr _e727;
  Expr _e728;
  Expr _e729;
  Expr _e730;
  Expr _e731;
  Expr _e732;
  Expr _e733;
  Expr _e734;
  Expr _e735;
  Expr _e736;
  Expr _e737;
  Expr _e738;
  Expr _e739;
  Expr _e740;
  Expr _e741;
  Expr _e742;
  Expr _e743;
  Expr _e744;
  Expr _e745;
  Expr _e746;
  Expr _e747;
  Expr _e748;
  Expr _e749;
  Expr _e750;
  Expr _e751;
  Expr _e752;
  Expr _e753;
  Expr _e754;
  Expr _e755;
  Expr _e756;
  Expr _e757;
  Expr _e758;
  Expr _e759;
  Expr _e760;
  Expr _e761;
  Expr _e762;
  Expr _e763;
  Expr _e764;
  Expr _e765;
  Expr _e766;
  Expr _e767;
  Expr _e768;
  Expr _e769;
  Expr _e770;
  Expr _e771;
  Expr _e772;
  Expr _e773;
  Expr _e774;
  Expr _e775;
  Expr _e776;
  Expr _e777;
  Expr _e778;
  Expr _e779;
  Expr _e780;
  Expr _e781;
  Expr _e782;
  Expr _e783;
  Expr _e784;
  Expr _e785;
  Expr _e786;
  Expr _e787;
  Expr _e788;
  Expr _e789;
  Expr _e790;
  Expr _e791;
  Expr _e792;
  Expr _e793;
  Expr _e794;
  Expr _e795;
  Expr _e796;
  Expr _e797;
  Expr _e798;
  Expr _e799;
  Expr _e800;
  Expr _e801;
  Expr _e802;
  Expr _e803;
  Expr _e804;
  Expr _e805;
  Expr _e806;
  Expr _e807;
  Expr _e808;
  Expr _e809;
  Expr _e810;
  Expr _e811;
  Expr _e812;
  Expr _e813;
  Expr _e814;
  Expr _e815;
  Expr _e816;
  Expr _e817;
  Expr _e818;
  Expr _e819;
  Expr _e820;
  Expr _e821;
  Expr _e822;
  Expr _e823;
  Expr _e824;
  Expr _e825;
  Expr _e826;
  Expr _e827;
  Expr _e828;
  Expr _e829;
  Expr _e830;
  Expr _e831;
  Expr _e832;
  Expr _e833;
  Expr _e834;
  Expr _e835;
  Expr _e836;
  Expr _e837;
  Expr _e838;
  Expr _e839;
  Expr _e840;
  Expr _e841;
  Expr _e842;
  Expr _e843;
  Expr _e844;
  Expr _e845;
  Expr _e846;
  Expr _e847;
  Expr _e848;
  Expr _e849;
  Expr _e850;
  Expr _e851;
  Expr _e852;
  Expr _e853;
  Expr _e854;
  Expr _e855;
  Expr _e856;
  Expr _e857;
  Expr _e858;
  Expr _e859;
  Expr _e860;
  Expr _e861;
  Expr _e862;
  Expr _e863;
  Expr _e864;
  Expr _e865;
  Expr _e866;
  Expr _e867;
  Expr _e868;
  Expr _e869;
  Expr _e870;
  Expr _e871;
  Expr _e872;
  Expr _e873;
  Expr _e874;
  Expr _e875;
  Expr _e876;
  Expr _e877;
  Expr _e878;
  Expr _e879;
  Expr _e880;
  Expr _e881;
  Expr _e882;
  Expr _e883;
  Expr _e884;
  Expr _e885;
  Expr _e886;
  Expr _e887;
  Expr _e888;
  Expr _e889;
  Expr _e890;
  Expr _e891;
  Expr _e892;
  Expr _e893;
  Expr _e894;
  Expr _e895;
  Expr _e896;
  Expr _e897;
  Expr _e898;
  Expr _e899;
  Expr _e900;
  Expr _e901;
  Expr _e902;
  Expr _e903;
  Expr _e904;
  Expr _e905;
  Expr _e906;
  Expr _e907;
  Expr _e908;
  Expr _e909;
  Expr _e910;
  Expr _e911;
  Expr _e912;
  Expr _e913;
  Expr _e914;
  Expr _e915;
  Expr _e916;
  Expr _e917;
  Expr _e918;
  Expr _e919;
  Expr _e920;
  Expr _e921;
  Expr _e922;
  Expr _e923;
  Expr _e924;
  Expr _e925;
  Expr _e926;
  Expr _e927;
  Expr _e928;
  Expr _e929;
  Expr _e930;
  Expr _e931;
  Expr _e932;
  Expr _e933;
  Expr _e934;
  Expr _e935;
  Expr _e936;
  Expr _e937;
  Expr _e938;
  Expr _e939;
  Expr _e940;
  Expr _e941;
  Expr _e942;
  Expr _e943;
  Expr _e944;
  Expr _e945;
  Expr _e946;
  Expr _e947;
  Expr _e948;
  Expr _e949;
  Expr _e950;
  Expr _e951;
  Expr _e952;
  Expr _e953;
  Expr _e954;
  Expr _e955;
  Expr _e956;
  Expr _e957;
  Expr _e958;
  Expr _e959;
  Expr _e960;
  Expr _e961;
  Expr _e962;
  Expr _e963;
  Expr _e964;
  Expr _e965;
  Expr _e966;
  Expr _e967;
  Expr _e968;
  Expr _e969;
  Expr _e970;
  Expr _e971;
  Expr _e972;
  Expr _e973;
  Expr _e974;
  Expr _e975;
  Expr _e976;
  Expr _e977;
  Expr _e978;
  Expr _e979;
  Expr _e980;
  Expr _e981;
  Expr _e982;
  Expr _e983;
  Expr _e984;
  Expr _e985;
  Expr _e986;
  Expr _e987;
  Expr _e988;
  Expr _e989;
  Expr _e990;
  Expr _e991;
  Expr _e992;
  Expr _e993;
  Expr _e994;
  Expr _e995;
  Expr _e996;
  Expr _e997;
  Expr _e998;
  Expr _e999;
  Expr _e1000;
  Expr _e1001;
  Expr _e1002;
  Expr _e1003;
  Expr _e1004;
  Expr _e1005;
  Expr _e1006;
  Expr _e1007;
  Expr _e1008;
  Expr _e1009;
  Expr _e1010;
  Expr _e1011;
  Expr _e1012;
  Expr _e1013;
  Expr _e1014;
  Expr _e1015;
  Expr _e1016;
  Expr _e1017;
  Expr _e1018;
  Expr _e1019;
  Expr _e1020;
  Expr _e1021;
  Expr _e1022;
  Expr _e1023;
  Expr _e1024;
  Expr _e1025;
  Expr _e1026;
  Expr _e1027;
  Expr _e1028;
  Expr _e1029;
  Expr _e1030;
  Expr _e1031;
  Expr _e1032;
  Expr _e1033;
  Expr _e1034;
  Expr _e1035;
  Expr _e1036;
  Expr _e1037;
  Expr _e1038;
  Expr _e1039;
  Expr _e1040;
  Expr _e1041;
  Expr _e1042;
  Expr _e1043;
  Expr _e1044;
  Expr _e1045;
  Expr _e1046;
  Expr _e1047;
  Expr _e1048;
  Expr _e1049;
  Expr _e1050;
  Expr _e1051;
  Expr _e1052;
  Expr _e1053;
  Expr _e1054;
  Expr _e1055;
  Expr _e1056;
  Expr _e1057;
  Expr _e1058;
  Expr _e1059;
  Expr _e1060;
  Expr _e1061;
  Expr _e1062;
  Expr _e1063;
  Expr _e1064;
  Expr _e1065;
  Expr _e1066;
  Expr _e1067;
  Expr _e1068;
  Expr _e1069;
  Expr _e1070;
  Expr _e1071;
  Expr _e1072;
  Expr _e1073;
  Expr _e1074;
  Expr _e1075;
  Expr _e1076;
  Expr _e1077;
  Expr _e1078;
  Expr _e1079;
  Expr _e1080;
  Expr _e1081;
  Expr _e1082;
  Expr _e1083;
  Expr _e1084;
  Expr _e1085;
  Expr _e1086;
  Expr _e1087;
  Expr _e1088;
  Expr _e1089;
  Expr _e1090;
  Expr _e1091;
  Expr _e1092;
  Expr _e1093;
  Expr _e1094;
  Expr _e1095;
  Expr _e1096;
  Expr _e1097;
  Expr _e1098;
  Expr _e1099;
  Expr _e1100;
  Expr _e1101;
  Expr _e1102;
  Expr _e1103;
  Expr _e1104;
  Expr _e1105;
  Expr _e1106;
  Expr _e1107;
  Expr _e1108;
  Expr _e1109;
  Expr _e1110;
  Expr _e1111;
  Expr _e1112;
  Expr _e1113;
  Expr _e1114;
  Expr _e1115;
  Expr _e1116;
  Expr _e1117;
  Expr _e1118;
  Expr _e1119;
  Expr _e1120;
  Expr _e1121;
  Expr _e1122;
  Expr _e1123;
  Expr _e1124;
  Expr _e1125;
  Expr _e1126;
  Expr _e1127;
  Expr _e1128;
  Expr _e1129;
  Expr _e1130;
  Expr _e1131;
  Expr _e1132;
  Expr _e1133;
  Expr _e1134;
  Expr _e1135;
  Expr _e1136;
  Expr _e1137;
  Expr _e1138;
  Expr _e1139;
  Expr _e1140;
  Expr _e1141;
  Expr _e1142;
  Expr _e1143;
  Expr _e1144;
  Expr _e1145;
  Expr _e1146;
  Expr _e1147;
  Expr _e1148;
  Expr _e1149;
  Expr _e1150;

void State::run_initialize()
{
  includeFileInternal("Cvc5.smt2", true);
  _e2 = d_type;
  _e1 = mkSymbolInternal(Kind::CONST, "Theory", _e2);
  bind("Theory", _e1);
  _e3 = mkSymbolInternal(Kind::CONST, "THEORY_BUILTIN", _e1);
  bind("THEORY_BUILTIN", _e3);
  _amap.clear();
  markAttributes(_e3, _amap);
  _e4 = mkSymbolInternal(Kind::CONST, "THEORY_BOOL", _e1);
  bind("THEORY_BOOL", _e4);
  _amap.clear();
  markAttributes(_e4, _amap);
  _e5 = mkSymbolInternal(Kind::CONST, "THEORY_UF", _e1);
  bind("THEORY_UF", _e5);
  _amap.clear();
  markAttributes(_e5, _amap);
  _e6 = mkSymbolInternal(Kind::CONST, "THEORY_ARITH", _e1);
  bind("THEORY_ARITH", _e6);
  _amap.clear();
  markAttributes(_e6, _amap);
  _e7 = mkSymbolInternal(Kind::CONST, "THEORY_BV", _e1);
  bind("THEORY_BV", _e7);
  _amap.clear();
  markAttributes(_e7, _amap);
  _e8 = mkSymbolInternal(Kind::CONST, "THEORY_FF", _e1);
  bind("THEORY_FF", _e8);
  _amap.clear();
  markAttributes(_e8, _amap);
  _e9 = mkSymbolInternal(Kind::CONST, "THEORY_FP", _e1);
  bind("THEORY_FP", _e9);
  _amap.clear();
  markAttributes(_e9, _amap);
  _e10 = mkSymbolInternal(Kind::CONST, "THEORY_ARRAYS", _e1);
  bind("THEORY_ARRAYS", _e10);
  _amap.clear();
  markAttributes(_e10, _amap);
  _e11 = mkSymbolInternal(Kind::CONST, "THEORY_DATATYPES", _e1);
  bind("THEORY_DATATYPES", _e11);
  _amap.clear();
  markAttributes(_e11, _amap);
  _e12 = mkSymbolInternal(Kind::CONST, "THEORY_SEP", _e1);
  bind("THEORY_SEP", _e12);
  _amap.clear();
  markAttributes(_e12, _amap);
  _e13 = mkSymbolInternal(Kind::CONST, "THEORY_SETS", _e1);
  bind("THEORY_SETS", _e13);
  _amap.clear();
  markAttributes(_e13, _amap);
  _e14 = mkSymbolInternal(Kind::CONST, "THEORY_BAGS", _e1);
  bind("THEORY_BAGS", _e14);
  _amap.clear();
  markAttributes(_e14, _amap);
  _e15 = mkSymbolInternal(Kind::CONST, "THEORY_STRINGS", _e1);
  bind("THEORY_STRINGS", _e15);
  _amap.clear();
  markAttributes(_e15, _amap);
  _e16 = mkSymbolInternal(Kind::CONST, "THEORY_QUANTIFIERS", _e1);
  bind("THEORY_QUANTIFIERS", _e16);
  _amap.clear();
  markAttributes(_e16, _amap);
  _e17 = mkSymbolInternal(Kind::CONST, "Method", _e2);
  bind("Method", _e17);
  _e18 = mkSymbolInternal(Kind::CONST, "RW_REWRITE", _e17);
  bind("RW_REWRITE", _e18);
  _amap.clear();
  markAttributes(_e18, _amap);
  _e19 = mkSymbolInternal(Kind::CONST, "RW_EXT_REWRITE", _e17);
  bind("RW_EXT_REWRITE", _e19);
  _amap.clear();
  markAttributes(_e19, _amap);
  _e20 = mkSymbolInternal(Kind::CONST, "RW_REWRITE_EQ_EXT", _e17);
  bind("RW_REWRITE_EQ_EXT", _e20);
  _amap.clear();
  markAttributes(_e20, _amap);
  _e21 = mkSymbolInternal(Kind::CONST, "RW_EVALUATE", _e17);
  bind("RW_EVALUATE", _e21);
  _amap.clear();
  markAttributes(_e21, _amap);
  _e22 = mkSymbolInternal(Kind::CONST, "RW_REWRITE_THEORY_PRE", _e17);
  bind("RW_REWRITE_THEORY_PRE", _e22);
  _amap.clear();
  markAttributes(_e22, _amap);
  _e23 = mkSymbolInternal(Kind::CONST, "RW_REWRITE_THEORY_POST", _e17);
  bind("RW_REWRITE_THEORY_POST", _e23);
  _amap.clear();
  markAttributes(_e23, _amap);
  _e24 = mkSymbolInternal(Kind::CONST, "SB_DEFAULT", _e17);
  bind("SB_DEFAULT", _e24);
  _amap.clear();
  markAttributes(_e24, _amap);
  _e25 = mkSymbolInternal(Kind::CONST, "SB_LITERAL", _e17);
  bind("SB_LITERAL", _e25);
  _amap.clear();
  markAttributes(_e25, _amap);
  _e26 = mkSymbolInternal(Kind::CONST, "SB_FORMULA", _e17);
  bind("SB_FORMULA", _e26);
  _amap.clear();
  markAttributes(_e26, _amap);
  _e27 = mkSymbolInternal(Kind::CONST, "SBA_SEQUENTIAL", _e17);
  bind("SBA_SEQUENTIAL", _e27);
  _amap.clear();
  markAttributes(_e27, _amap);
  _e28 = mkSymbolInternal(Kind::CONST, "SBA_SIMUL", _e17);
  bind("SBA_SIMUL", _e28);
  _amap.clear();
  markAttributes(_e28, _amap);
  _e29 = mkSymbolInternal(Kind::CONST, "SBA_FIXPOINT", _e17);
  bind("SBA_FIXPOINT", _e29);
  _amap.clear();
  markAttributes(_e29, _amap);
  _e32 = mkSymbolInternal(Kind::PARAM, "T", _e2);
  _e31 = mkSymbolInternal(Kind::PARAM, "F", _e32);
  _e33 = mkExprInternal(Kind::PROOF_TYPE, {_e31});
  _e34 = mkSymbolInternal(Kind::PARAM, "method", _e17);
  _e35 = mkExprInternal(Kind::QUOTE_TYPE, {_e34});
  _e36 = mkSymbolInternal(Kind::PARAM, "theory", _e1);
  _e37 = mkExprInternal(Kind::QUOTE_TYPE, {_e36});
  _e38 = mkExprInternal(Kind::QUOTE_TYPE, {_e31});
  _e39 = mkExprInternal(Kind::FUNCTION_TYPE, {_e38, _e37, _e35, _e33});
  _e30 = mkSymbolInternal(Kind::PROOF_RULE, "theory_rewrite", _e39);
  bind("theory_rewrite", _e30);
  _runId[_e39.get()] = 39;
  _e39->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e42 = d_boolType;
  _e41 = mkSymbolInternal(Kind::PARAM, "F", _e42);
  _e43 = mkExprInternal(Kind::PROOF_TYPE, {_e41});
  _e44 = mkExprInternal(Kind::QUOTE_TYPE, {_e41});
  _e45 = mkExprInternal(Kind::FUNCTION_TYPE, {_e44, _e43});
  _e40 = mkSymbolInternal(Kind::PROOF_RULE, "trust", _e45);
  bind("trust", _e40);
  _runId[_e45.get()] = 45;
  _e45->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e47 = mkSymbolInternal(Kind::PARAM, "A", _e2);
  _e48 = mkExprInternal(Kind::FUNCTION_TYPE, {_e47, _e47});
  _e48->d_type = _e2;
  _e49 = mkExprInternal(Kind::FUNCTION_TYPE, {_e47, _e48});
  _e49->d_type = _e2;
  _e50 = mkExprInternal(Kind::FUNCTION_TYPE, {_e42, _e49});
  _e50->d_type = _e2;
  _e46 = mkSymbolInternal(Kind::CONST, "ite", _e50);
  bind("ite", _e46);
  _runId[_e50.get()] = 50;
  _e50->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _runId[_e49.get()] = 49;
  _e49->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  markAttributes(_e46, _amap);
  _e52 = mkExprInternal(Kind::FUNCTION_TYPE, {_e42, _e42});
  _e52->d_type = _e2;
  _e51 = mkSymbolInternal(Kind::CONST, "not", _e52);
  bind("not", _e51);
  _runId[_e52.get()] = 52;
  _e52->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  markAttributes(_e51, _amap);
  _e54 = mkSymbolInternal(Kind::PARAM, "A", _e2);
  _e55 = mkExprInternal(Kind::FUNCTION_TYPE, {_e54, _e42});
  _e55->d_type = _e2;
  _e56 = mkExprInternal(Kind::FUNCTION_TYPE, {_e54, _e55});
  _e56->d_type = _e2;
  _e53 = mkSymbolInternal(Kind::CONST, "distinct", _e56);
  bind("distinct", _e53);
  _runId[_e56.get()] = 56;
  _e56->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  markAttributes(_e53, _amap);
  _e58 = mkExprInternal(Kind::FUNCTION_TYPE, {_e42, _e52});
  _e58->d_type = _e2;
  _e57 = mkSymbolInternal(Kind::CONST, "or", _e58);
  bind("or", _e57);
  _runId[_e58.get()] = 58;
  _e58->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  _amap[Attr::RIGHT_ASSOC_NIL].push_back(nullptr);
  markAttributes(_e57, _amap);
  _e59 = mkSymbolInternal(Kind::CONST, "and", _e58);
  bind("and", _e59);
  _amap.clear();
  _amap[Attr::RIGHT_ASSOC_NIL].push_back(nullptr);
  markAttributes(_e59, _amap);
  _e60 = mkSymbolInternal(Kind::CONST, "=>", _e58);
  bind("=>", _e60);
  _amap.clear();
  _amap[Attr::RIGHT_ASSOC].push_back(nullptr);
  markAttributes(_e60, _amap);
  _e61 = mkSymbolInternal(Kind::CONST, "xor", _e58);
  bind("xor", _e61);
  _amap.clear();
  _amap[Attr::LEFT_ASSOC].push_back(nullptr);
  markAttributes(_e61, _amap);
  _e63 = mkSymbolInternal(Kind::PARAM, "A", _e2);
  _e64 = mkExprInternal(Kind::FUNCTION_TYPE, {_e63, _e42});
  _e64->d_type = _e2;
  _e65 = mkExprInternal(Kind::FUNCTION_TYPE, {_e63, _e64});
  _e65->d_type = _e2;
  _e62 = mkSymbolInternal(Kind::CONST, "=", _e65);
  bind("=", _e62);
  _runId[_e65.get()] = 65;
  _e65->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  _amap[Attr::CHAINABLE].push_back(_e59);
  markAttributes(_e62, _amap);
  _e67 = mkSymbolInternal(Kind::PARAM, "A", _e2);
  _e68 = mkExprInternal(Kind::FUNCTION_TYPE, {_e67, _e42});
  _e68->d_type = _e2;
  _e69 = mkExprInternal(Kind::FUNCTION_TYPE, {_e68, _e42});
  _e69->d_type = _e2;
  _e66 = mkSymbolInternal(Kind::CONST, "forall", _e69);
  bind("forall", _e66);
  _runId[_e69.get()] = 69;
  _e69->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  markAttributes(_e66, _amap);
  _e71 = mkSymbolInternal(Kind::PARAM, "A", _e2);
  _e72 = mkExprInternal(Kind::FUNCTION_TYPE, {_e71, _e42});
  _e72->d_type = _e2;
  _e73 = mkExprInternal(Kind::FUNCTION_TYPE, {_e72, _e42});
  _e73->d_type = _e2;
  _e70 = mkSymbolInternal(Kind::CONST, "exists", _e73);
  bind("exists", _e70);
  _runId[_e73.get()] = 73;
  _e73->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  markAttributes(_e70, _amap);
  _e75 = mkSymbolInternal(Kind::PARAM, "A", _e2);
  _e76 = mkExprInternal(Kind::FUNCTION_TYPE, {_e75, _e42});
  _e76->d_type = _e2;
  _e77 = mkExprInternal(Kind::FUNCTION_TYPE, {_e76, _e75});
  _e77->d_type = _e2;
  _e74 = mkSymbolInternal(Kind::CONST, "choose", _e77);
  bind("choose", _e74);
  _runId[_e77.get()] = 77;
  _e77->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  markAttributes(_e74, _amap);
  _e79 = mkSymbolInternal(Kind::PARAM, "C", _e2);
  _e80 = mkSymbolInternal(Kind::PARAM, "A", _e2);
  _e81 = mkExprInternal(Kind::FUNCTION_TYPE, {_e80, _e79});
  _e81->d_type = _e2;
  _e82 = mkSymbolInternal(Kind::PARAM, "B", _e2);
  _e83 = mkExprInternal(Kind::FUNCTION_TYPE, {_e80, _e82});
  _e83->d_type = _e2;
  _e84 = mkExprInternal(Kind::FUNCTION_TYPE, {_e83, _e81});
  _e84->d_type = _e2;
  _e85 = mkExprInternal(Kind::FUNCTION_TYPE, {_e82, _e79});
  _e85->d_type = _e2;
  _e86 = mkExprInternal(Kind::FUNCTION_TYPE, {_e85, _e84});
  _e86->d_type = _e2;
  _e78 = mkSymbolInternal(Kind::CONST, "compose", _e86);
  bind("compose", _e78);
  _runId[_e86.get()] = 86;
  _e86->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  markAttributes(_e78, _amap);
  _e88 = mkSymbolInternal(Kind::PARAM, "A", _e2);
  _e89 = mkExprInternal(Kind::FUNCTION_TYPE, {_e88, _e88});
  _e89->d_type = _e2;
  _e87 = mkSymbolInternal(Kind::CONST, "iden", _e89);
  bind("iden", _e87);
  _runId[_e89.get()] = 89;
  _e89->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  markAttributes(_e87, _amap);
  _e91 = mkSymbolInternal(Kind::PARAM, "B", _e2);
  _e92 = mkSymbolInternal(Kind::PARAM, "A", _e2);
  _e93 = mkExprInternal(Kind::FUNCTION_TYPE, {_e92, _e91});
  _e93->d_type = _e2;
  _e94 = mkExprInternal(Kind::FUNCTION_TYPE, {_e93, _e93});
  _e94->d_type = _e2;
  _e90 = mkSymbolInternal(Kind::CONST, "apply", _e94);
  bind("apply", _e90);
  _runId[_e94.get()] = 94;
  _e94->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  _amap[Attr::LEFT_ASSOC_NIL].push_back(nullptr);
  markAttributes(_e90, _amap);
  _e95 = mkSymbolInternal(Kind::CONST, "Int", _e2);
  bind("Int", _e95);
  _e96 = mkSymbolInternal(Kind::CONST, "Real", _e2);
  bind("Real", _e96);
  _e98 = mkExprInternal(Kind::FUNCTION_TYPE, {_e96, _e95});
  _e98->d_type = _e2;
  _e97 = mkSymbolInternal(Kind::CONST, "to_int", _e98);
  bind("to_int", _e97);
  _runId[_e98.get()] = 98;
  _e98->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  markAttributes(_e97, _amap);
  _e100 = mkExprInternal(Kind::FUNCTION_TYPE, {_e95, _e96});
  _e100->d_type = _e2;
  _e99 = mkSymbolInternal(Kind::CONST, "to_real", _e100);
  bind("to_real", _e99);
  _runId[_e100.get()] = 100;
  _e100->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  markAttributes(_e99, _amap);
  d_tc.setLiteralTypeRule(Kind::NUMERAL, _e95);
  _e102 = mkExprInternal(Kind::FUNCTION_TYPE, {_e95, _e95});
  _e102->d_type = _e2;
  _e101 = mkSymbolInternal(Kind::CONST, "+1", _e102);
  bind("+1", _e101);
  _runId[_e102.get()] = 102;
  _e102->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  markAttributes(_e101, _amap);
  _e103 = mkSymbolInternal(Kind::CONST, "-1", _e102);
  bind("-1", _e103);
  _amap.clear();
  markAttributes(_e103, _amap);
  _e105 = mkExprInternal(Kind::FUNCTION_TYPE, {_e95, _e42});
  _e105->d_type = _e2;
  _e106 = mkExprInternal(Kind::FUNCTION_TYPE, {_e95, _e105});
  _e106->d_type = _e2;
  _e104 = mkSymbolInternal(Kind::CONST, "<", _e106);
  bind("<", _e104);
  _runId[_e106.get()] = 106;
  _e106->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _runId[_e105.get()] = 105;
  _e105->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  _amap[Attr::CHAINABLE].push_back(_e59);
  markAttributes(_e104, _amap);
  _e107 = mkSymbolInternal(Kind::CONST, "<=", _e106);
  bind("<=", _e107);
  _amap.clear();
  _amap[Attr::CHAINABLE].push_back(_e59);
  markAttributes(_e107, _amap);
  _e108 = mkSymbolInternal(Kind::CONST, ">", _e106);
  bind(">", _e108);
  _amap.clear();
  _amap[Attr::CHAINABLE].push_back(_e59);
  markAttributes(_e108, _amap);
  _e109 = mkSymbolInternal(Kind::CONST, ">=", _e106);
  bind(">=", _e109);
  _amap.clear();
  _amap[Attr::CHAINABLE].push_back(_e59);
  markAttributes(_e109, _amap);
  _e111 = mkExprInternal(Kind::FUNCTION_TYPE, {_e95, _e102});
  _e111->d_type = _e2;
  _e110 = mkSymbolInternal(Kind::CONST, "+", _e111);
  bind("+", _e110);
  _runId[_e111.get()] = 111;
  _e111->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  _amap[Attr::RIGHT_ASSOC_NIL].push_back(nullptr);
  markAttributes(_e110, _amap);
  _e112 = mkSymbolInternal(Kind::CONST, "-", _e111);
  bind("-", _e112);
  _amap.clear();
  _amap[Attr::LEFT_ASSOC].push_back(nullptr);
  markAttributes(_e112, _amap);
  _e113 = mkSymbolInternal(Kind::CONST, "*", _e111);
  bind("*", _e113);
  _amap.clear();
  _amap[Attr::RIGHT_ASSOC_NIL].push_back(nullptr);
  markAttributes(_e113, _amap);
  _e114 = mkSymbolInternal(Kind::CONST, "abs", _e102);
  bind("abs", _e114);
  _amap.clear();
  markAttributes(_e114, _amap);
  _e116 = mkSymbolInternal(Kind::PARAM, "n", _e95);
  _e117 = mkExprInternal(Kind::QUOTE_TYPE, {_e116});
  _e117->d_type = _e2;
  _e118 = mkExprInternal(Kind::FUNCTION_TYPE, {_e117, _e95});
  _e118->d_type = _e2;
  _e119 = mkExprInternal(Kind::FUNCTION_TYPE, {_e95, _e118});
  _e119->d_type = _e2;
  _e115 = mkSymbolInternal(Kind::CONST, "div", _e119);
  bind("div", _e115);
  _runId[_e119.get()] = 119;
  _e119->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _runId[_e118.get()] = 118;
  _e118->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  _amap[Attr::LEFT_ASSOC].push_back(nullptr);
  markAttributes(_e115, _amap);
  _e120 = mkSymbolInternal(Kind::CONST, "mod", _e111);
  bind("mod", _e120);
  _amap.clear();
  markAttributes(_e120, _amap);
  _e122 = mkSymbolInternal(Kind::PARAM, "n", _e95);
  _e123 = mkExprInternal(Kind::QUOTE_TYPE, {_e122});
  _e123->d_type = _e2;
  _e124 = mkExprInternal(Kind::FUNCTION_TYPE, {_e123, _e42});
  _e124->d_type = _e2;
  _e125 = mkExprInternal(Kind::FUNCTION_TYPE, {_e95, _e124});
  _e125->d_type = _e2;
  _e121 = mkSymbolInternal(Kind::CONST, "divisible", _e125);
  bind("divisible", _e121);
  _runId[_e125.get()] = 125;
  _e125->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _runId[_e124.get()] = 124;
  _e124->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  markAttributes(_e121, _amap);
  _e127 = mkExprInternal(Kind::FUNCTION_TYPE, {_e102, _e95});
  _e127->d_type = _e2;
  _e128 = mkExprInternal(Kind::FUNCTION_TYPE, {_e95, _e127});
  _e128->d_type = _e2;
  _e129 = mkExprInternal(Kind::FUNCTION_TYPE, {_e95, _e128});
  _e129->d_type = _e2;
  _e126 = mkSymbolInternal(Kind::CONST, "sum", _e129);
  bind("sum", _e126);
  _runId[_e129.get()] = 129;
  _e129->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _runId[_e128.get()] = 128;
  _e128->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _runId[_e127.get()] = 127;
  _e127->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  markAttributes(_e126, _amap);
  _e131 = mkSymbolInternal(Kind::PARAM, "S", _e2);
  _e132 = mkSymbolInternal(Kind::PARAM, "U", _e2);
  _e133 = mkExprInternal(Kind::FUNCTION_TYPE, {_e132, _e132, _e131, _e131, _e131});
  _e130 = mkSymbolInternal(Kind::PROGRAM_CONST, "ifEqThenElse", _e133);
  _runId[_e130.get()] = 130;
  _e130->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e134 = mkSymbolInternal(Kind::PARAM, "t1", _e131);
  _e135 = mkSymbolInternal(Kind::PARAM, "t2", _e131);
  bind("ifEqThenElse", _e130);
  _runId[_e133.get()] = 133;
  _e133->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e137 = mkSymbolInternal(Kind::PARAM, "L", _e2);
  _e138 = mkExprInternal(Kind::FUNCTION_TYPE, {_e137, _e137});
  _e138->d_type = _e2;
  _e139 = mkExprInternal(Kind::FUNCTION_TYPE, {_e137, _e138});
  _e139->d_type = _e2;
  _e140 = mkExprInternal(Kind::FUNCTION_TYPE, {_e139, _e137, _e137, _e137});
  _e136 = mkSymbolInternal(Kind::PROGRAM_CONST, "append", _e140);
  _runId[_e136.get()] = 136;
  _e136->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e141 = mkSymbolInternal(Kind::PARAM, "xs", _e137);
  _e142 = mkSymbolInternal(Kind::PARAM, "c", _e137);
  _e143 = mkSymbolInternal(Kind::PARAM, "cons", _e139);
  _e144 = mkExprInternal(Kind::APPLY, {_e143, _e142});
  _e145 = mkExprInternal(Kind::APPLY, {_e144, _e141});
  _runId[_e145.get()] = 145;
  _e145->setFlag(ExprValue::Flag::IS_COMPILED, true);
  bind("append", _e136);
  _runId[_e140.get()] = 140;
  _e140->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e147 = mkSymbolInternal(Kind::PARAM, "L", _e2);
  _e148 = mkExprInternal(Kind::FUNCTION_TYPE, {_e147, _e147});
  _e148->d_type = _e2;
  _e149 = mkExprInternal(Kind::FUNCTION_TYPE, {_e147, _e148});
  _e149->d_type = _e2;
  _e150 = mkExprInternal(Kind::FUNCTION_TYPE, {_e149, _e147, _e147, _e147});
  _e146 = mkSymbolInternal(Kind::PROGRAM_CONST, "concat", _e150);
  _runId[_e146.get()] = 146;
  _e146->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e151 = mkSymbolInternal(Kind::PARAM, "ys", _e147);
  _e152 = mkSymbolInternal(Kind::PARAM, "xs", _e147);
  _e153 = mkSymbolInternal(Kind::PARAM, "cons", _e149);
  _e154 = mkExprInternal(Kind::APPLY, {_e146, _e153, _e152, _e151});
  _e155 = mkSymbolInternal(Kind::PARAM, "x", _e147);
  _e156 = mkExprInternal(Kind::APPLY, {_e136, _e153, _e155, _e154});
  bind("concat", _e146);
  _runId[_e150.get()] = 150;
  _e150->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e158 = mkSymbolInternal(Kind::PARAM, "L", _e2);
  _e159 = mkExprInternal(Kind::FUNCTION_TYPE, {_e158, _e158});
  _e159->d_type = _e2;
  _e160 = mkExprInternal(Kind::FUNCTION_TYPE, {_e158, _e159});
  _e160->d_type = _e2;
  _e161 = mkExprInternal(Kind::FUNCTION_TYPE, {_e160, _e158, _e158, _e158});
  _e157 = mkSymbolInternal(Kind::PROGRAM_CONST, "remove", _e161);
  _runId[_e157.get()] = 157;
  _e157->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e162 = mkNil(_e158);
  _runId[_e162.get()] = 162;
  _e162->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e163 = mkSymbolInternal(Kind::PARAM, "xs", _e158);
  _e164 = mkSymbolInternal(Kind::PARAM, "c", _e158);
  _e165 = mkSymbolInternal(Kind::PARAM, "cons", _e160);
  _e166 = mkExprInternal(Kind::APPLY, {_e157, _e165, _e164, _e163});
  _e167 = mkSymbolInternal(Kind::PARAM, "y", _e158);
  _e168 = mkExprInternal(Kind::APPLY, {_e136, _e165, _e167, _e166});
  bind("remove", _e157);
  _runId[_e161.get()] = 161;
  _e161->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e170 = mkSymbolInternal(Kind::PARAM, "L", _e2);
  _e171 = mkExprInternal(Kind::FUNCTION_TYPE, {_e170, _e170});
  _e171->d_type = _e2;
  _e172 = mkExprInternal(Kind::FUNCTION_TYPE, {_e170, _e171});
  _e172->d_type = _e2;
  _e173 = mkExprInternal(Kind::FUNCTION_TYPE, {_e172, _e170, _e170, _e170});
  _e169 = mkSymbolInternal(Kind::PROGRAM_CONST, "reverseRec", _e173);
  _runId[_e169.get()] = 169;
  _e169->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e174 = mkSymbolInternal(Kind::PARAM, "l", _e170);
  _e175 = mkSymbolInternal(Kind::PARAM, "x", _e170);
  _e176 = mkSymbolInternal(Kind::PARAM, "cons", _e172);
  _e177 = mkExprInternal(Kind::APPLY, {_e136, _e176, _e175, _e174});
  _e178 = mkSymbolInternal(Kind::PARAM, "xs", _e170);
  _e179 = mkExprInternal(Kind::APPLY, {_e169, _e176, _e178, _e177});
  bind("reverseRec", _e169);
  _runId[_e173.get()] = 173;
  _e173->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e181 = mkSymbolInternal(Kind::PARAM, "L", _e2);
  _e182 = mkExprInternal(Kind::FUNCTION_TYPE, {_e181, _e181});
  _e182->d_type = _e2;
  _e183 = mkExprInternal(Kind::FUNCTION_TYPE, {_e181, _e182});
  _e183->d_type = _e2;
  _e184 = mkExprInternal(Kind::FUNCTION_TYPE, {_e183, _e181, _e181, _e181});
  _e180 = mkSymbolInternal(Kind::PROGRAM_CONST, "reverse", _e184);
  _runId[_e180.get()] = 180;
  _e180->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e185 = mkSymbolInternal(Kind::PARAM, "nil", _e181);
  _e186 = mkSymbolInternal(Kind::PARAM, "xs", _e181);
  _e187 = mkSymbolInternal(Kind::PARAM, "cons", _e183);
  _e188 = mkExprInternal(Kind::APPLY, {_e169, _e187, _e186, _e185});
  bind("reverse", _e180);
  _runId[_e184.get()] = 184;
  _e184->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e190 = mkSymbolInternal(Kind::PARAM, "L", _e2);
  _e191 = mkExprInternal(Kind::FUNCTION_TYPE, {_e190, _e190});
  _e191->d_type = _e2;
  _e192 = mkExprInternal(Kind::FUNCTION_TYPE, {_e190, _e191});
  _e192->d_type = _e2;
  _e193 = mkExprInternal(Kind::FUNCTION_TYPE, {_e192, _e190, _e190, _e190, _e190});
  _e189 = mkSymbolInternal(Kind::PROGRAM_CONST, "naryElim", _e193);
  _runId[_e189.get()] = 189;
  _e189->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e194 = mkSymbolInternal(Kind::PARAM, "c", _e190);
  _e195 = mkSymbolInternal(Kind::PARAM, "x", _e190);
  _e196 = mkSymbolInternal(Kind::PARAM, "xs", _e190);
  _e197 = mkSymbolInternal(Kind::PARAM, "cons", _e192);
  _e198 = mkExprInternal(Kind::APPLY, {_e136, _e197, _e195, _e196});
  bind("naryElim", _e189);
  _runId[_e193.get()] = 193;
  _e193->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e200 = mkSymbolInternal(Kind::PARAM, "L", _e2);
  _e201 = mkExprInternal(Kind::FUNCTION_TYPE, {_e200, _e200});
  _e201->d_type = _e2;
  _e202 = mkExprInternal(Kind::FUNCTION_TYPE, {_e200, _e201});
  _e202->d_type = _e2;
  _e203 = mkExprInternal(Kind::FUNCTION_TYPE, {_e202, _e200, _e200, _e200});
  _e199 = mkSymbolInternal(Kind::PROGRAM_CONST, "naryIntro", _e203);
  _runId[_e199.get()] = 199;
  _e199->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e204 = mkSymbolInternal(Kind::PARAM, "xs", _e200);
  _e205 = mkSymbolInternal(Kind::PARAM, "x", _e200);
  _e206 = mkSymbolInternal(Kind::PARAM, "cons", _e202);
  _e207 = mkExprInternal(Kind::APPLY, {_e136, _e206, _e205, _e204});
  _e208 = mkSymbolInternal(Kind::PARAM, "nil", _e200);
  _e209 = mkExprInternal(Kind::APPLY, {_e136, _e206, _e205, _e208});
  bind("naryIntro", _e199);
  _runId[_e203.get()] = 203;
  _e203->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e211 = mkSymbolInternal(Kind::PARAM, "L", _e2);
  _e212 = mkSymbolInternal(Kind::PARAM, "I", _e2);
  _e213 = mkExprInternal(Kind::FUNCTION_TYPE, {_e211, _e211});
  _e213->d_type = _e2;
  _e214 = mkExprInternal(Kind::FUNCTION_TYPE, {_e211, _e213});
  _e214->d_type = _e2;
  _e215 = mkExprInternal(Kind::FUNCTION_TYPE, {_e214, _e212, _e211, _e211});
  _e210 = mkSymbolInternal(Kind::PROGRAM_CONST, "at", _e215);
  _runId[_e210.get()] = 210;
  _e210->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e216 = mkLiteral(Kind::NUMERAL, "0");
  _e217 = mkSymbolInternal(Kind::PARAM, "x", _e211);
  _e218 = mkLiteral(Kind::NUMERAL, "-1");
  _e219 = mkSymbolInternal(Kind::PARAM, "i", _e212);
  _e220 = mkExprInternal(Kind::EVAL_ADD, {_e219, _e218});
  _runId[_e220.get()] = 220;
  _e220->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e221 = mkSymbolInternal(Kind::PARAM, "xs", _e211);
  _e222 = mkSymbolInternal(Kind::PARAM, "cons", _e214);
  _e223 = mkExprInternal(Kind::APPLY, {_e210, _e222, _e220, _e221});
  bind("at", _e210);
  _runId[_e215.get()] = 215;
  _e215->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e225 = mkSymbolInternal(Kind::PARAM, "S", _e2);
  _e226 = mkExprInternal(Kind::FUNCTION_TYPE, {_e42, _e225, _e225, _e225});
  _e224 = mkSymbolInternal(Kind::PROGRAM_CONST, "ifThenElse", _e226);
  _runId[_e224.get()] = 224;
  _e224->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e227 = mkLiteral(Kind::BOOLEAN, "true");
  _e228 = mkSymbolInternal(Kind::PARAM, "t1", _e225);
  _e229 = mkLiteral(Kind::BOOLEAN, "false");
  _e230 = mkSymbolInternal(Kind::PARAM, "t2", _e225);
  bind("ifThenElse", _e224);
  _runId[_e226.get()] = 226;
  _e226->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e232 = mkSymbolInternal(Kind::PARAM, "L", _e2);
  _e233 = mkExprInternal(Kind::FUNCTION_TYPE, {_e232, _e232});
  _e233->d_type = _e2;
  _e234 = mkExprInternal(Kind::FUNCTION_TYPE, {_e232, _e233});
  _e234->d_type = _e2;
  _e235 = mkExprInternal(Kind::FUNCTION_TYPE, {_e234, _e232, _e232, _e42});
  _e231 = mkSymbolInternal(Kind::PROGRAM_CONST, "inList", _e235);
  _runId[_e231.get()] = 231;
  _e231->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e236 = mkSymbolInternal(Kind::PARAM, "xs", _e232);
  _e237 = mkSymbolInternal(Kind::PARAM, "c", _e232);
  _e238 = mkSymbolInternal(Kind::PARAM, "cons", _e234);
  _e239 = mkExprInternal(Kind::APPLY, {_e231, _e238, _e237, _e236});
  bind("inList", _e231);
  _runId[_e235.get()] = 235;
  _e235->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e241 = mkExprInternal(Kind::FUNCTION_TYPE, {_e42, _e42, _e42});
  _e240 = mkSymbolInternal(Kind::PROGRAM_CONST, "inListOr", _e241);
  _runId[_e240.get()] = 240;
  _e240->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e242 = mkSymbolInternal(Kind::PARAM, "l", _e42);
  _e243 = mkSymbolInternal(Kind::PARAM, "c", _e42);
  _e244 = mkExprInternal(Kind::APPLY, {_e231, _e57, _e243, _e242});
  bind("inListOr", _e240);
  _runId[_e241.get()] = 241;
  _e241->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e245 = mkSymbolInternal(Kind::PROGRAM_CONST, "appendOr", _e241);
  _runId[_e245.get()] = 245;
  _e245->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e246 = mkSymbolInternal(Kind::PARAM, "l", _e42);
  _e247 = mkSymbolInternal(Kind::PARAM, "c", _e42);
  _e248 = mkExprInternal(Kind::APPLY, {_e136, _e57, _e247, _e246});
  bind("appendOr", _e245);
  _e249 = mkSymbolInternal(Kind::PROGRAM_CONST, "concatOr", _e241);
  _runId[_e249.get()] = 249;
  _e249->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e250 = mkSymbolInternal(Kind::PARAM, "l2", _e42);
  _e251 = mkSymbolInternal(Kind::PARAM, "l1", _e42);
  _e252 = mkExprInternal(Kind::APPLY, {_e146, _e57, _e251, _e250});
  bind("concatOr", _e249);
  _e253 = mkSymbolInternal(Kind::PROGRAM_CONST, "removeOr", _e241);
  _runId[_e253.get()] = 253;
  _e253->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e254 = mkSymbolInternal(Kind::PARAM, "l", _e42);
  _e255 = mkSymbolInternal(Kind::PARAM, "c", _e42);
  _e256 = mkExprInternal(Kind::APPLY, {_e157, _e57, _e255, _e254});
  bind("removeOr", _e253);
  _e257 = mkSymbolInternal(Kind::PROGRAM_CONST, "reverseOr", _e52);
  _runId[_e257.get()] = 257;
  _e257->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e258 = mkNil(_e42);
  _e259 = mkSymbolInternal(Kind::PARAM, "xs", _e42);
  _e260 = mkExprInternal(Kind::APPLY, {_e180, _e57, _e258, _e259});
  bind("reverseOr", _e257);
  _e261 = mkSymbolInternal(Kind::PROGRAM_CONST, "naryElimOr", _e52);
  _runId[_e261.get()] = 261;
  _e261->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e262 = mkSymbolInternal(Kind::PARAM, "t", _e42);
  _e263 = mkExprInternal(Kind::APPLY, {_e189, _e57, _e258, _e229, _e262});
  bind("naryElimOr", _e261);
  _e264 = mkSymbolInternal(Kind::PROGRAM_CONST, "naryIntroOr", _e52);
  _runId[_e264.get()] = 264;
  _e264->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e265 = mkSymbolInternal(Kind::PARAM, "t", _e42);
  _e266 = mkExprInternal(Kind::APPLY, {_e199, _e57, _e258, _e265});
  bind("naryIntroOr", _e264);
  _e267 = mkSymbolInternal(Kind::PROGRAM_CONST, "inListAnd", _e241);
  _runId[_e267.get()] = 267;
  _e267->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e268 = mkSymbolInternal(Kind::PARAM, "l", _e42);
  _e269 = mkSymbolInternal(Kind::PARAM, "c", _e42);
  _e270 = mkExprInternal(Kind::APPLY, {_e231, _e59, _e269, _e268});
  bind("inListAnd", _e267);
  _e271 = mkSymbolInternal(Kind::PROGRAM_CONST, "appendAnd", _e241);
  _runId[_e271.get()] = 271;
  _e271->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e272 = mkSymbolInternal(Kind::PARAM, "l", _e42);
  _e273 = mkSymbolInternal(Kind::PARAM, "c", _e42);
  _e274 = mkExprInternal(Kind::APPLY, {_e136, _e59, _e273, _e272});
  bind("appendAnd", _e271);
  _e275 = mkSymbolInternal(Kind::PROGRAM_CONST, "concatAnd", _e241);
  _runId[_e275.get()] = 275;
  _e275->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e276 = mkSymbolInternal(Kind::PARAM, "l2", _e42);
  _e277 = mkSymbolInternal(Kind::PARAM, "l1", _e42);
  _e278 = mkExprInternal(Kind::APPLY, {_e146, _e59, _e277, _e276});
  bind("concatAnd", _e275);
  _e279 = mkSymbolInternal(Kind::PROGRAM_CONST, "removeAnd", _e241);
  _runId[_e279.get()] = 279;
  _e279->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e280 = mkSymbolInternal(Kind::PARAM, "l", _e42);
  _e281 = mkSymbolInternal(Kind::PARAM, "c", _e42);
  _e282 = mkExprInternal(Kind::APPLY, {_e157, _e59, _e281, _e280});
  bind("removeAnd", _e279);
  _e283 = mkSymbolInternal(Kind::PROGRAM_CONST, "reverseAnd", _e52);
  _runId[_e283.get()] = 283;
  _e283->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e284 = mkSymbolInternal(Kind::PARAM, "xs", _e42);
  _e285 = mkExprInternal(Kind::APPLY, {_e180, _e59, _e258, _e284});
  bind("reverseAnd", _e283);
  _e286 = mkSymbolInternal(Kind::PROGRAM_CONST, "naryElimAnd", _e52);
  _runId[_e286.get()] = 286;
  _e286->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e287 = mkSymbolInternal(Kind::PARAM, "t", _e42);
  _e288 = mkExprInternal(Kind::APPLY, {_e189, _e59, _e258, _e227, _e287});
  bind("naryElimAnd", _e286);
  _e289 = mkSymbolInternal(Kind::PROGRAM_CONST, "naryIntroAnd", _e52);
  _runId[_e289.get()] = 289;
  _e289->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e290 = mkSymbolInternal(Kind::PARAM, "t", _e42);
  _e291 = mkExprInternal(Kind::APPLY, {_e199, _e59, _e258, _e290});
  bind("naryIntroAnd", _e289);
  _e293 = mkSymbolInternal(Kind::PARAM, "G", _e42);
  _e294 = mkSymbolInternal(Kind::PARAM, "F", _e42);
  _e295 = mkExprInternal(Kind::APPLY, {_e60, _e294});
  _e296 = mkExprInternal(Kind::APPLY, {_e295, _e293});
  _e297 = mkExprInternal(Kind::PROOF_TYPE, {_e296});
  _e298 = mkExprInternal(Kind::PROOF_TYPE, {_e293});
  _e299 = mkExprInternal(Kind::QUOTE_TYPE, {_e294});
  _e300 = mkExprInternal(Kind::FUNCTION_TYPE, {_e299, _e298, _e297});
  _e292 = mkSymbolInternal(Kind::PROOF_RULE, "scope", _e300);
  bind("scope", _e292);
  _runId[_e300.get()] = 300;
  _e300->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e301 = mkSymbolInternal(Kind::PROGRAM_CONST, "extract_antec", _e241);
  _runId[_e301.get()] = 301;
  _e301->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e302 = mkSymbolInternal(Kind::PARAM, "C", _e42);
  _e303 = mkSymbolInternal(Kind::PARAM, "F2", _e42);
  _e304 = mkExprInternal(Kind::APPLY, {_e301, _e303, _e302});
  _e305 = mkSymbolInternal(Kind::PARAM, "F1", _e42);
  _e306 = mkExprInternal(Kind::APPLY, {_e271, _e305, _e304});
  bind("extract_antec", _e301);
  _e307 = mkSymbolInternal(Kind::PROGRAM_CONST, "run_process_scope", _e241);
  _runId[_e307.get()] = 307;
  _e307->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e308 = mkSymbolInternal(Kind::PARAM, "F", _e42);
  _e309 = mkExprInternal(Kind::APPLY, {_e301, _e308, _e229});
  _e310 = mkExprInternal(Kind::APPLY, {_e286, _e309});
  _e311 = mkExprInternal(Kind::APPLY, {_e51, _e310});
  _e312 = mkSymbolInternal(Kind::PARAM, "C", _e42);
  _e313 = mkExprInternal(Kind::APPLY, {_e301, _e308, _e312});
  _e314 = mkExprInternal(Kind::APPLY, {_e286, _e313});
  _e315 = mkExprInternal(Kind::APPLY, {_e60, _e314});
  _e316 = mkExprInternal(Kind::APPLY, {_e315, _e312});
  bind("run_process_scope", _e307);
  _e318 = mkSymbolInternal(Kind::PARAM, "C", _e42);
  _e319 = mkSymbolInternal(Kind::PARAM, "F", _e42);
  _e320 = mkExprInternal(Kind::APPLY, {_e307, _e319, _e318});
  _e321 = mkExprInternal(Kind::PROOF_TYPE, {_e320});
  _e322 = mkExprInternal(Kind::QUOTE_TYPE, {_e318});
  _e323 = mkExprInternal(Kind::PROOF_TYPE, {_e319});
  _e324 = mkExprInternal(Kind::FUNCTION_TYPE, {_e323, _e322, _e321});
  _e317 = mkSymbolInternal(Kind::PROOF_RULE, "process_scope", _e324);
  bind("process_scope", _e317);
  _runId[_e324.get()] = 324;
  _e324->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e326 = mkSymbolInternal(Kind::PARAM, "F", _e42);
  _e327 = mkExprInternal(Kind::APPLY, {_e51, _e326});
  _e328 = mkExprInternal(Kind::APPLY, {_e57, _e327});
  _e329 = mkExprInternal(Kind::APPLY, {_e328, _e258});
  _e330 = mkExprInternal(Kind::APPLY, {_e57, _e326});
  _e331 = mkExprInternal(Kind::APPLY, {_e330, _e329});
  _e332 = mkExprInternal(Kind::PROOF_TYPE, {_e331});
  _e333 = mkExprInternal(Kind::QUOTE_TYPE, {_e326});
  _e334 = mkExprInternal(Kind::FUNCTION_TYPE, {_e333, _e332});
  _e325 = mkSymbolInternal(Kind::PROOF_RULE, "split", _e334);
  bind("split", _e325);
  _runId[_e334.get()] = 334;
  _e334->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e335 = mkSymbolInternal(Kind::PROGRAM_CONST, "removeSelf", _e241);
  _runId[_e335.get()] = 335;
  _e335->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e336 = mkSymbolInternal(Kind::PARAM, "C", _e42);
  _e337 = mkSymbolInternal(Kind::PARAM, "l", _e42);
  _e338 = mkExprInternal(Kind::APPLY, {_e253, _e337, _e336});
  bind("removeSelf", _e335);
  _e340 = mkExprInternal(Kind::FUNCTION_TYPE, {_e42, _e42, _e42, _e42, _e42});
  _e339 = mkSymbolInternal(Kind::PROGRAM_CONST, "resolve", _e340);
  _runId[_e339.get()] = 339;
  _e339->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e341 = mkSymbolInternal(Kind::PARAM, "L", _e42);
  _e342 = mkExprInternal(Kind::APPLY, {_e51, _e341});
  _runId[_e342.get()] = 342;
  _e342->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e343 = mkSymbolInternal(Kind::PARAM, "C2", _e42);
  _e344 = mkExprInternal(Kind::APPLY, {_e264, _e343});
  _e345 = mkExprInternal(Kind::APPLY, {_e335, _e342, _e344});
  _e346 = mkSymbolInternal(Kind::PARAM, "C1", _e42);
  _e347 = mkExprInternal(Kind::APPLY, {_e264, _e346});
  _e348 = mkExprInternal(Kind::APPLY, {_e335, _e341, _e347});
  _e349 = mkExprInternal(Kind::APPLY, {_e249, _e348, _e345});
  _e350 = mkExprInternal(Kind::APPLY, {_e261, _e349});
  _e351 = mkExprInternal(Kind::APPLY, {_e335, _e341, _e344});
  _e352 = mkExprInternal(Kind::APPLY, {_e335, _e342, _e347});
  _e353 = mkExprInternal(Kind::APPLY, {_e249, _e352, _e351});
  _e354 = mkExprInternal(Kind::APPLY, {_e261, _e353});
  bind("resolve", _e339);
  _runId[_e340.get()] = 340;
  _e340->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e356 = mkSymbolInternal(Kind::PARAM, "L", _e42);
  _e357 = mkSymbolInternal(Kind::PARAM, "pol", _e42);
  _e358 = mkSymbolInternal(Kind::PARAM, "C2", _e42);
  _e359 = mkSymbolInternal(Kind::PARAM, "C1", _e42);
  _e360 = mkExprInternal(Kind::APPLY, {_e339, _e359, _e358, _e357, _e356});
  _e361 = mkExprInternal(Kind::PROOF_TYPE, {_e360});
  _e362 = mkExprInternal(Kind::QUOTE_TYPE, {_e356});
  _e363 = mkExprInternal(Kind::QUOTE_TYPE, {_e357});
  _e364 = mkExprInternal(Kind::PROOF_TYPE, {_e358});
  _e365 = mkExprInternal(Kind::PROOF_TYPE, {_e359});
  _e366 = mkExprInternal(Kind::FUNCTION_TYPE, {_e365, _e364, _e363, _e362, _e361});
  _e355 = mkSymbolInternal(Kind::PROOF_RULE, "resolution", _e366);
  bind("resolution", _e355);
  _runId[_e366.get()] = 366;
  _e366->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e368 = mkExprInternal(Kind::FUNCTION_TYPE, {_e42, _e42, _e42, _e42});
  _e367 = mkSymbolInternal(Kind::PROGRAM_CONST, "chainResolveRec", _e368);
  _runId[_e367.get()] = 367;
  _e367->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e369 = mkSymbolInternal(Kind::PARAM, "C1", _e42);
  _e370 = mkSymbolInternal(Kind::PARAM, "args", _e42);
  _e371 = mkSymbolInternal(Kind::PARAM, "Cs", _e42);
  _e372 = mkSymbolInternal(Kind::PARAM, "L", _e42);
  _e373 = mkSymbolInternal(Kind::PARAM, "pol", _e42);
  _e374 = mkSymbolInternal(Kind::PARAM, "C2", _e42);
  _e375 = mkExprInternal(Kind::APPLY, {_e339, _e369, _e374, _e373, _e372});
  _e376 = mkExprInternal(Kind::APPLY, {_e367, _e375, _e371, _e370});
  bind("chainResolveRec", _e367);
  _runId[_e368.get()] = 368;
  _e368->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e377 = mkSymbolInternal(Kind::PROGRAM_CONST, "chainResolve", _e241);
  _runId[_e377.get()] = 377;
  _e377->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e378 = mkSymbolInternal(Kind::PARAM, "args", _e42);
  _e379 = mkSymbolInternal(Kind::PARAM, "Cs", _e42);
  _e380 = mkSymbolInternal(Kind::PARAM, "C1", _e42);
  _e381 = mkExprInternal(Kind::APPLY, {_e367, _e380, _e379, _e378});
  bind("chainResolve", _e377);
  _e383 = mkSymbolInternal(Kind::PARAM, "args", _e42);
  _e384 = mkSymbolInternal(Kind::PARAM, "Cs", _e42);
  _e385 = mkExprInternal(Kind::APPLY, {_e377, _e384, _e383});
  _e386 = mkExprInternal(Kind::PROOF_TYPE, {_e385});
  _e387 = mkExprInternal(Kind::QUOTE_TYPE, {_e383});
  _e388 = mkExprInternal(Kind::PROOF_TYPE, {_e384});
  _e389 = mkExprInternal(Kind::FUNCTION_TYPE, {_e388, _e387, _e386});
  _e382 = mkSymbolInternal(Kind::PROOF_RULE, "chain_resolution", _e389);
  bind("chain_resolution", _e382);
  _runId[_e389.get()] = 389;
  _e389->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e391 = mkSymbolInternal(Kind::PARAM, "C", _e42);
  _e392 = mkExprInternal(Kind::PROOF_TYPE, {_e391});
  _e393 = mkSymbolInternal(Kind::PARAM, "args", _e42);
  _e394 = mkExprInternal(Kind::QUOTE_TYPE, {_e393});
  _e395 = mkExprInternal(Kind::QUOTE_TYPE, {_e391});
  _e396 = mkSymbolInternal(Kind::PARAM, "Cs", _e42);
  _e397 = mkExprInternal(Kind::PROOF_TYPE, {_e396});
  _e398 = mkExprInternal(Kind::FUNCTION_TYPE, {_e397, _e395, _e394, _e392});
  _e390 = mkSymbolInternal(Kind::PROOF_RULE, "macro_resolution_trust", _e398);
  bind("macro_resolution_trust", _e390);
  _runId[_e398.get()] = 398;
  _e398->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e400 = mkSymbolInternal(Kind::PARAM, "C", _e42);
  _e401 = mkExprInternal(Kind::PROOF_TYPE, {_e400});
  _e402 = mkSymbolInternal(Kind::PARAM, "args", _e42);
  _e403 = mkExprInternal(Kind::QUOTE_TYPE, {_e402});
  _e404 = mkExprInternal(Kind::QUOTE_TYPE, {_e400});
  _e405 = mkSymbolInternal(Kind::PARAM, "Cs", _e42);
  _e406 = mkExprInternal(Kind::PROOF_TYPE, {_e405});
  _e407 = mkExprInternal(Kind::FUNCTION_TYPE, {_e406, _e404, _e403, _e401});
  _e399 = mkSymbolInternal(Kind::PROOF_RULE, "macro_resolution", _e407);
  bind("macro_resolution", _e399);
  _runId[_e407.get()] = 407;
  _e407->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e408 = mkSymbolInternal(Kind::PROGRAM_CONST, "factorLiterals", _e241);
  _runId[_e408.get()] = 408;
  _e408->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e409 = mkSymbolInternal(Kind::PARAM, "xs", _e42);
  _e410 = mkExprInternal(Kind::APPLY, {_e261, _e409});
  _e411 = mkSymbolInternal(Kind::PARAM, "ls", _e42);
  _e412 = mkSymbolInternal(Kind::PARAM, "l", _e42);
  _e413 = mkExprInternal(Kind::APPLY, {_e245, _e412, _e409});
  _e414 = mkExprInternal(Kind::APPLY, {_e240, _e412, _e409});
  _e415 = mkExprInternal(Kind::APPLY, {_e224, _e414, _e409, _e413});
  _e416 = mkExprInternal(Kind::APPLY, {_e408, _e415, _e411});
  bind("factorLiterals", _e408);
  _e418 = mkSymbolInternal(Kind::PARAM, "C", _e42);
  _e419 = mkExprInternal(Kind::APPLY, {_e408, _e258, _e418});
  _e420 = mkExprInternal(Kind::APPLY, {_e257, _e419});
  _e421 = mkExprInternal(Kind::PROOF_TYPE, {_e420});
  _e422 = mkExprInternal(Kind::PROOF_TYPE, {_e418});
  _e423 = mkExprInternal(Kind::FUNCTION_TYPE, {_e422, _e421});
  _e417 = mkSymbolInternal(Kind::PROOF_RULE, "factoring", _e423);
  bind("factoring", _e417);
  _runId[_e423.get()] = 423;
  _e423->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e424 = mkSymbolInternal(Kind::PROGRAM_CONST, "isPermutation", _e241);
  _runId[_e424.get()] = 424;
  _e424->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e425 = mkSymbolInternal(Kind::PARAM, "l2s", _e42);
  _e426 = mkSymbolInternal(Kind::PARAM, "l2", _e42);
  _e427 = mkExprInternal(Kind::APPLY, {_e57, _e426});
  _e428 = mkExprInternal(Kind::APPLY, {_e427, _e425});
  _runId[_e428.get()] = 428;
  _e428->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e429 = mkSymbolInternal(Kind::PARAM, "l1", _e42);
  _e430 = mkExprInternal(Kind::APPLY, {_e253, _e429, _e428});
  _e431 = mkSymbolInternal(Kind::PARAM, "l1s", _e42);
  _e432 = mkExprInternal(Kind::APPLY, {_e424, _e431, _e430});
  bind("isPermutation", _e424);
  _e434 = mkSymbolInternal(Kind::PARAM, "C2", _e42);
  _e435 = mkExprInternal(Kind::PROOF_TYPE, {_e434});
  _e436 = mkSymbolInternal(Kind::PARAM, "C1", _e42);
  _e437 = mkExprInternal(Kind::APPLY, {_e424, _e436, _e434});
  _e438 = mkExprInternal(Kind::PAIR, {_e437, _e227});
  _e439 = mkExprInternal(Kind::REQUIRES_TYPE, {_e438, _e435});
  _e440 = mkExprInternal(Kind::QUOTE_TYPE, {_e434});
  _e441 = mkExprInternal(Kind::PROOF_TYPE, {_e436});
  _e442 = mkExprInternal(Kind::FUNCTION_TYPE, {_e441, _e440, _e439});
  _e433 = mkSymbolInternal(Kind::PROOF_RULE, "reordering", _e442);
  bind("reordering", _e433);
  _runId[_e442.get()] = 442;
  _e442->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e444 = mkSymbolInternal(Kind::PARAM, "F2", _e42);
  _e445 = mkExprInternal(Kind::PROOF_TYPE, {_e444});
  _e446 = mkSymbolInternal(Kind::PARAM, "F1", _e42);
  _e447 = mkExprInternal(Kind::APPLY, {_e62, _e446});
  _e448 = mkExprInternal(Kind::APPLY, {_e447, _e444});
  _e449 = mkExprInternal(Kind::PROOF_TYPE, {_e448});
  _e450 = mkExprInternal(Kind::PROOF_TYPE, {_e446});
  _e451 = mkExprInternal(Kind::FUNCTION_TYPE, {_e450, _e449, _e445});
  _e443 = mkSymbolInternal(Kind::PROOF_RULE, "eq_resolve", _e451);
  bind("eq_resolve", _e443);
  _runId[_e451.get()] = 451;
  _e451->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e453 = mkSymbolInternal(Kind::PARAM, "F2", _e42);
  _e454 = mkExprInternal(Kind::PROOF_TYPE, {_e453});
  _e455 = mkSymbolInternal(Kind::PARAM, "F1", _e42);
  _e456 = mkExprInternal(Kind::APPLY, {_e60, _e455});
  _e457 = mkExprInternal(Kind::APPLY, {_e456, _e453});
  _e458 = mkExprInternal(Kind::PROOF_TYPE, {_e457});
  _e459 = mkExprInternal(Kind::PROOF_TYPE, {_e455});
  _e460 = mkExprInternal(Kind::FUNCTION_TYPE, {_e459, _e458, _e454});
  _e452 = mkSymbolInternal(Kind::PROOF_RULE, "modus_ponens", _e460);
  bind("modus_ponens", _e452);
  _runId[_e460.get()] = 460;
  _e460->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e462 = mkSymbolInternal(Kind::PARAM, "F", _e42);
  _e463 = mkExprInternal(Kind::PROOF_TYPE, {_e462});
  _e464 = mkExprInternal(Kind::APPLY, {_e51, _e462});
  _e465 = mkExprInternal(Kind::APPLY, {_e51, _e464});
  _e466 = mkExprInternal(Kind::PROOF_TYPE, {_e465});
  _e467 = mkExprInternal(Kind::FUNCTION_TYPE, {_e466, _e463});
  _e461 = mkSymbolInternal(Kind::PROOF_RULE, "not_not_elim", _e467);
  bind("not_not_elim", _e461);
  _runId[_e467.get()] = 467;
  _e467->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e469 = mkExprInternal(Kind::PROOF_TYPE, {_e229});
  _e470 = mkSymbolInternal(Kind::PARAM, "F", _e42);
  _e471 = mkExprInternal(Kind::APPLY, {_e51, _e470});
  _e472 = mkExprInternal(Kind::PROOF_TYPE, {_e471});
  _e473 = mkExprInternal(Kind::PROOF_TYPE, {_e470});
  _e474 = mkExprInternal(Kind::FUNCTION_TYPE, {_e473, _e472, _e469});
  _e468 = mkSymbolInternal(Kind::PROOF_RULE, "contra", _e474);
  bind("contra", _e468);
  _runId[_e474.get()] = 474;
  _e474->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e476 = mkSymbolInternal(Kind::PARAM, "Fs", _e42);
  _e477 = mkSymbolInternal(Kind::PARAM, "i", _e95);
  _e478 = mkExprInternal(Kind::APPLY, {_e210, _e59, _e477, _e476});
  _e479 = mkExprInternal(Kind::PROOF_TYPE, {_e478});
  _e480 = mkExprInternal(Kind::QUOTE_TYPE, {_e477});
  _e481 = mkExprInternal(Kind::PROOF_TYPE, {_e476});
  _e482 = mkExprInternal(Kind::FUNCTION_TYPE, {_e481, _e480, _e479});
  _e475 = mkSymbolInternal(Kind::PROOF_RULE, "and_elim", _e482);
  bind("and_elim", _e475);
  _runId[_e482.get()] = 482;
  _e482->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e484 = mkSymbolInternal(Kind::PARAM, "Fs", _e42);
  _e485 = mkSymbolInternal(Kind::PARAM, "F", _e42);
  _e486 = mkExprInternal(Kind::APPLY, {_e271, _e485, _e484});
  _e487 = mkExprInternal(Kind::PROOF_TYPE, {_e486});
  _e488 = mkExprInternal(Kind::PROOF_TYPE, {_e484});
  _e489 = mkExprInternal(Kind::PROOF_TYPE, {_e485});
  _e490 = mkExprInternal(Kind::FUNCTION_TYPE, {_e489, _e488, _e487});
  _e483 = mkSymbolInternal(Kind::PROOF_RULE, "and_intro_nary", _e490);
  bind("and_intro_nary", _e483);
  _runId[_e490.get()] = 490;
  _e490->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e492 = mkSymbolInternal(Kind::PARAM, "F2", _e42);
  _e493 = mkExprInternal(Kind::APPLY, {_e59, _e492});
  _e494 = mkExprInternal(Kind::APPLY, {_e493, _e258});
  _e495 = mkSymbolInternal(Kind::PARAM, "F1", _e42);
  _e496 = mkExprInternal(Kind::APPLY, {_e59, _e495});
  _e497 = mkExprInternal(Kind::APPLY, {_e496, _e494});
  _e498 = mkExprInternal(Kind::PROOF_TYPE, {_e497});
  _e499 = mkExprInternal(Kind::PROOF_TYPE, {_e492});
  _e500 = mkExprInternal(Kind::PROOF_TYPE, {_e495});
  _e501 = mkExprInternal(Kind::FUNCTION_TYPE, {_e500, _e499, _e498});
  _e491 = mkSymbolInternal(Kind::PROOF_RULE, "and_intro", _e501);
  bind("and_intro", _e491);
  _runId[_e501.get()] = 501;
  _e501->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e503 = mkSymbolInternal(Kind::PARAM, "Fs", _e42);
  _e504 = mkSymbolInternal(Kind::PARAM, "i", _e95);
  _e505 = mkExprInternal(Kind::APPLY, {_e210, _e57, _e504, _e503});
  _e506 = mkExprInternal(Kind::APPLY, {_e51, _e505});
  _e507 = mkExprInternal(Kind::PROOF_TYPE, {_e506});
  _e508 = mkExprInternal(Kind::QUOTE_TYPE, {_e504});
  _e509 = mkExprInternal(Kind::APPLY, {_e51, _e503});
  _e510 = mkExprInternal(Kind::PROOF_TYPE, {_e509});
  _e511 = mkExprInternal(Kind::FUNCTION_TYPE, {_e510, _e508, _e507});
  _e502 = mkSymbolInternal(Kind::PROOF_RULE, "not_or_elim", _e511);
  bind("not_or_elim", _e502);
  _runId[_e511.get()] = 511;
  _e511->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e513 = mkSymbolInternal(Kind::PARAM, "F2", _e42);
  _e514 = mkExprInternal(Kind::APPLY, {_e57, _e513});
  _e515 = mkExprInternal(Kind::APPLY, {_e514, _e258});
  _e516 = mkSymbolInternal(Kind::PARAM, "F1", _e42);
  _e517 = mkExprInternal(Kind::APPLY, {_e51, _e516});
  _e517->d_type = _e42;
  _e518 = mkExprInternal(Kind::APPLY, {_e57, _e517});
  _e519 = mkExprInternal(Kind::APPLY, {_e518, _e515});
  _e520 = mkExprInternal(Kind::PROOF_TYPE, {_e519});
  _e521 = mkExprInternal(Kind::APPLY, {_e60, _e516});
  _e522 = mkExprInternal(Kind::APPLY, {_e521, _e513});
  _e523 = mkExprInternal(Kind::PROOF_TYPE, {_e522});
  _e524 = mkExprInternal(Kind::FUNCTION_TYPE, {_e523, _e520});
  _e512 = mkSymbolInternal(Kind::PROOF_RULE, "implies_elim", _e524);
  bind("implies_elim", _e512);
  _runId[_e524.get()] = 524;
  _e524->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e526 = mkSymbolInternal(Kind::PARAM, "F1", _e42);
  _e527 = mkExprInternal(Kind::PROOF_TYPE, {_e526});
  _e528 = mkSymbolInternal(Kind::PARAM, "F2", _e42);
  _e529 = mkExprInternal(Kind::APPLY, {_e60, _e526});
  _e530 = mkExprInternal(Kind::APPLY, {_e529, _e528});
  _e531 = mkExprInternal(Kind::APPLY, {_e51, _e530});
  _e532 = mkExprInternal(Kind::PROOF_TYPE, {_e531});
  _e533 = mkExprInternal(Kind::FUNCTION_TYPE, {_e532, _e527});
  _e525 = mkSymbolInternal(Kind::PROOF_RULE, "not_implies_elim1", _e533);
  bind("not_implies_elim1", _e525);
  _runId[_e533.get()] = 533;
  _e533->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e535 = mkSymbolInternal(Kind::PARAM, "F2", _e42);
  _e536 = mkExprInternal(Kind::APPLY, {_e51, _e535});
  _e537 = mkExprInternal(Kind::PROOF_TYPE, {_e536});
  _e538 = mkSymbolInternal(Kind::PARAM, "F1", _e42);
  _e539 = mkExprInternal(Kind::APPLY, {_e60, _e538});
  _e540 = mkExprInternal(Kind::APPLY, {_e539, _e535});
  _e541 = mkExprInternal(Kind::APPLY, {_e51, _e540});
  _e542 = mkExprInternal(Kind::PROOF_TYPE, {_e541});
  _e543 = mkExprInternal(Kind::FUNCTION_TYPE, {_e542, _e537});
  _e534 = mkSymbolInternal(Kind::PROOF_RULE, "not_implies_elim2", _e543);
  bind("not_implies_elim2", _e534);
  _runId[_e543.get()] = 543;
  _e543->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e545 = mkSymbolInternal(Kind::PARAM, "F2", _e42);
  _e546 = mkExprInternal(Kind::APPLY, {_e57, _e545});
  _e547 = mkExprInternal(Kind::APPLY, {_e546, _e258});
  _e548 = mkSymbolInternal(Kind::PARAM, "F1", _e42);
  _e549 = mkExprInternal(Kind::APPLY, {_e51, _e548});
  _e549->d_type = _e42;
  _e550 = mkExprInternal(Kind::APPLY, {_e57, _e549});
  _e551 = mkExprInternal(Kind::APPLY, {_e550, _e547});
  _e552 = mkExprInternal(Kind::PROOF_TYPE, {_e551});
  _e553 = mkExprInternal(Kind::APPLY, {_e62, _e548});
  _e554 = mkExprInternal(Kind::APPLY, {_e553, _e545});
  _e555 = mkExprInternal(Kind::PROOF_TYPE, {_e554});
  _e556 = mkExprInternal(Kind::FUNCTION_TYPE, {_e555, _e552});
  _e544 = mkSymbolInternal(Kind::PROOF_RULE, "equiv_elim1", _e556);
  bind("equiv_elim1", _e544);
  _runId[_e556.get()] = 556;
  _e556->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e558 = mkSymbolInternal(Kind::PARAM, "F2", _e42);
  _e559 = mkExprInternal(Kind::APPLY, {_e51, _e558});
  _e560 = mkExprInternal(Kind::APPLY, {_e57, _e559});
  _e561 = mkExprInternal(Kind::APPLY, {_e560, _e258});
  _e562 = mkSymbolInternal(Kind::PARAM, "F1", _e42);
  _e563 = mkExprInternal(Kind::APPLY, {_e57, _e562});
  _e564 = mkExprInternal(Kind::APPLY, {_e563, _e561});
  _e565 = mkExprInternal(Kind::PROOF_TYPE, {_e564});
  _e566 = mkExprInternal(Kind::APPLY, {_e62, _e562});
  _e567 = mkExprInternal(Kind::APPLY, {_e566, _e558});
  _e568 = mkExprInternal(Kind::PROOF_TYPE, {_e567});
  _e569 = mkExprInternal(Kind::FUNCTION_TYPE, {_e568, _e565});
  _e557 = mkSymbolInternal(Kind::PROOF_RULE, "equiv_elim2", _e569);
  bind("equiv_elim2", _e557);
  _runId[_e569.get()] = 569;
  _e569->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e571 = mkSymbolInternal(Kind::PARAM, "F2", _e42);
  _e572 = mkExprInternal(Kind::APPLY, {_e57, _e571});
  _e573 = mkExprInternal(Kind::APPLY, {_e572, _e258});
  _e574 = mkSymbolInternal(Kind::PARAM, "F1", _e42);
  _e575 = mkExprInternal(Kind::APPLY, {_e57, _e574});
  _e576 = mkExprInternal(Kind::APPLY, {_e575, _e573});
  _e577 = mkExprInternal(Kind::PROOF_TYPE, {_e576});
  _e578 = mkExprInternal(Kind::APPLY, {_e62, _e574});
  _e579 = mkExprInternal(Kind::APPLY, {_e578, _e571});
  _e580 = mkExprInternal(Kind::APPLY, {_e51, _e579});
  _e581 = mkExprInternal(Kind::PROOF_TYPE, {_e580});
  _e582 = mkExprInternal(Kind::FUNCTION_TYPE, {_e581, _e577});
  _e570 = mkSymbolInternal(Kind::PROOF_RULE, "not_equiv_elim1", _e582);
  bind("not_equiv_elim1", _e570);
  _runId[_e582.get()] = 582;
  _e582->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e584 = mkSymbolInternal(Kind::PARAM, "F2", _e42);
  _e585 = mkExprInternal(Kind::APPLY, {_e51, _e584});
  _e586 = mkExprInternal(Kind::APPLY, {_e57, _e585});
  _e587 = mkExprInternal(Kind::APPLY, {_e586, _e258});
  _e588 = mkSymbolInternal(Kind::PARAM, "F1", _e42);
  _e589 = mkExprInternal(Kind::APPLY, {_e51, _e588});
  _e589->d_type = _e42;
  _e590 = mkExprInternal(Kind::APPLY, {_e57, _e589});
  _e591 = mkExprInternal(Kind::APPLY, {_e590, _e587});
  _e592 = mkExprInternal(Kind::PROOF_TYPE, {_e591});
  _e593 = mkExprInternal(Kind::APPLY, {_e62, _e588});
  _e594 = mkExprInternal(Kind::APPLY, {_e593, _e584});
  _e595 = mkExprInternal(Kind::APPLY, {_e51, _e594});
  _e596 = mkExprInternal(Kind::PROOF_TYPE, {_e595});
  _e597 = mkExprInternal(Kind::FUNCTION_TYPE, {_e596, _e592});
  _e583 = mkSymbolInternal(Kind::PROOF_RULE, "not_equiv_elim2", _e597);
  bind("not_equiv_elim2", _e583);
  _runId[_e597.get()] = 597;
  _e597->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e599 = mkSymbolInternal(Kind::PARAM, "F2", _e42);
  _e600 = mkExprInternal(Kind::APPLY, {_e57, _e599});
  _e601 = mkExprInternal(Kind::APPLY, {_e600, _e258});
  _e602 = mkSymbolInternal(Kind::PARAM, "F1", _e42);
  _e603 = mkExprInternal(Kind::APPLY, {_e57, _e602});
  _e604 = mkExprInternal(Kind::APPLY, {_e603, _e601});
  _e605 = mkExprInternal(Kind::PROOF_TYPE, {_e604});
  _e606 = mkExprInternal(Kind::APPLY, {_e61, _e602});
  _e607 = mkExprInternal(Kind::APPLY, {_e606, _e599});
  _e608 = mkExprInternal(Kind::PROOF_TYPE, {_e607});
  _e609 = mkExprInternal(Kind::FUNCTION_TYPE, {_e608, _e605});
  _e598 = mkSymbolInternal(Kind::PROOF_RULE, "xor_elim1", _e609);
  bind("xor_elim1", _e598);
  _runId[_e609.get()] = 609;
  _e609->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e611 = mkSymbolInternal(Kind::PARAM, "F2", _e42);
  _e612 = mkExprInternal(Kind::APPLY, {_e51, _e611});
  _e613 = mkExprInternal(Kind::APPLY, {_e57, _e612});
  _e614 = mkExprInternal(Kind::APPLY, {_e613, _e258});
  _e615 = mkSymbolInternal(Kind::PARAM, "F1", _e42);
  _e616 = mkExprInternal(Kind::APPLY, {_e51, _e615});
  _e616->d_type = _e42;
  _e617 = mkExprInternal(Kind::APPLY, {_e57, _e616});
  _e618 = mkExprInternal(Kind::APPLY, {_e617, _e614});
  _e619 = mkExprInternal(Kind::PROOF_TYPE, {_e618});
  _e620 = mkExprInternal(Kind::APPLY, {_e61, _e615});
  _e621 = mkExprInternal(Kind::APPLY, {_e620, _e611});
  _e622 = mkExprInternal(Kind::PROOF_TYPE, {_e621});
  _e623 = mkExprInternal(Kind::FUNCTION_TYPE, {_e622, _e619});
  _e610 = mkSymbolInternal(Kind::PROOF_RULE, "xor_elim2", _e623);
  bind("xor_elim2", _e610);
  _runId[_e623.get()] = 623;
  _e623->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e625 = mkSymbolInternal(Kind::PARAM, "F2", _e42);
  _e626 = mkExprInternal(Kind::APPLY, {_e51, _e625});
  _e627 = mkExprInternal(Kind::APPLY, {_e57, _e626});
  _e628 = mkExprInternal(Kind::APPLY, {_e627, _e258});
  _e629 = mkSymbolInternal(Kind::PARAM, "F1", _e42);
  _e630 = mkExprInternal(Kind::APPLY, {_e57, _e629});
  _e631 = mkExprInternal(Kind::APPLY, {_e630, _e628});
  _e632 = mkExprInternal(Kind::PROOF_TYPE, {_e631});
  _e633 = mkExprInternal(Kind::APPLY, {_e61, _e629});
  _e634 = mkExprInternal(Kind::APPLY, {_e633, _e625});
  _e635 = mkExprInternal(Kind::APPLY, {_e51, _e634});
  _e636 = mkExprInternal(Kind::PROOF_TYPE, {_e635});
  _e637 = mkExprInternal(Kind::FUNCTION_TYPE, {_e636, _e632});
  _e624 = mkSymbolInternal(Kind::PROOF_RULE, "not_xor_elim1", _e637);
  bind("not_xor_elim1", _e624);
  _runId[_e637.get()] = 637;
  _e637->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e639 = mkSymbolInternal(Kind::PARAM, "F2", _e42);
  _e640 = mkExprInternal(Kind::APPLY, {_e57, _e639});
  _e641 = mkExprInternal(Kind::APPLY, {_e640, _e258});
  _e642 = mkSymbolInternal(Kind::PARAM, "F1", _e42);
  _e643 = mkExprInternal(Kind::APPLY, {_e51, _e642});
  _e643->d_type = _e42;
  _e644 = mkExprInternal(Kind::APPLY, {_e57, _e643});
  _e645 = mkExprInternal(Kind::APPLY, {_e644, _e641});
  _e646 = mkExprInternal(Kind::PROOF_TYPE, {_e645});
  _e647 = mkExprInternal(Kind::APPLY, {_e61, _e642});
  _e648 = mkExprInternal(Kind::APPLY, {_e647, _e639});
  _e649 = mkExprInternal(Kind::APPLY, {_e51, _e648});
  _e650 = mkExprInternal(Kind::PROOF_TYPE, {_e649});
  _e651 = mkExprInternal(Kind::FUNCTION_TYPE, {_e650, _e646});
  _e638 = mkSymbolInternal(Kind::PROOF_RULE, "not_xor_elim2", _e651);
  bind("not_xor_elim2", _e638);
  _runId[_e651.get()] = 651;
  _e651->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e653 = mkSymbolInternal(Kind::PARAM, "F1", _e42);
  _e654 = mkExprInternal(Kind::APPLY, {_e57, _e653});
  _e655 = mkExprInternal(Kind::APPLY, {_e654, _e258});
  _e656 = mkSymbolInternal(Kind::PARAM, "C", _e42);
  _e657 = mkExprInternal(Kind::APPLY, {_e51, _e656});
  _e657->d_type = _e42;
  _e658 = mkExprInternal(Kind::APPLY, {_e57, _e657});
  _e659 = mkExprInternal(Kind::APPLY, {_e658, _e655});
  _e660 = mkExprInternal(Kind::PROOF_TYPE, {_e659});
  _e661 = mkSymbolInternal(Kind::PARAM, "F2", _e42);
  _e662 = mkExprInternal(Kind::APPLY, {_e46, _e656});
  _e663 = mkExprInternal(Kind::APPLY, {_e662, _e653});
  _e664 = mkExprInternal(Kind::APPLY, {_e663, _e661});
  _e665 = mkExprInternal(Kind::PROOF_TYPE, {_e664});
  _e666 = mkExprInternal(Kind::FUNCTION_TYPE, {_e665, _e660});
  _e652 = mkSymbolInternal(Kind::PROOF_RULE, "ite_elim1", _e666);
  bind("ite_elim1", _e652);
  _runId[_e666.get()] = 666;
  _e666->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e668 = mkSymbolInternal(Kind::PARAM, "F2", _e42);
  _e669 = mkExprInternal(Kind::APPLY, {_e57, _e668});
  _e670 = mkExprInternal(Kind::APPLY, {_e669, _e258});
  _e671 = mkSymbolInternal(Kind::PARAM, "C", _e42);
  _e672 = mkExprInternal(Kind::APPLY, {_e57, _e671});
  _e673 = mkExprInternal(Kind::APPLY, {_e672, _e670});
  _e674 = mkExprInternal(Kind::PROOF_TYPE, {_e673});
  _e675 = mkSymbolInternal(Kind::PARAM, "F1", _e42);
  _e676 = mkExprInternal(Kind::APPLY, {_e46, _e671});
  _e677 = mkExprInternal(Kind::APPLY, {_e676, _e675});
  _e678 = mkExprInternal(Kind::APPLY, {_e677, _e668});
  _e679 = mkExprInternal(Kind::PROOF_TYPE, {_e678});
  _e680 = mkExprInternal(Kind::FUNCTION_TYPE, {_e679, _e674});
  _e667 = mkSymbolInternal(Kind::PROOF_RULE, "ite_elim2", _e680);
  bind("ite_elim2", _e667);
  _runId[_e680.get()] = 680;
  _e680->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e682 = mkSymbolInternal(Kind::PARAM, "F1", _e42);
  _e683 = mkExprInternal(Kind::APPLY, {_e51, _e682});
  _e684 = mkExprInternal(Kind::APPLY, {_e57, _e683});
  _e685 = mkExprInternal(Kind::APPLY, {_e684, _e258});
  _e686 = mkSymbolInternal(Kind::PARAM, "C", _e42);
  _e687 = mkExprInternal(Kind::APPLY, {_e51, _e686});
  _e687->d_type = _e42;
  _e688 = mkExprInternal(Kind::APPLY, {_e57, _e687});
  _e689 = mkExprInternal(Kind::APPLY, {_e688, _e685});
  _e690 = mkExprInternal(Kind::PROOF_TYPE, {_e689});
  _e691 = mkSymbolInternal(Kind::PARAM, "F2", _e42);
  _e692 = mkExprInternal(Kind::APPLY, {_e46, _e686});
  _e693 = mkExprInternal(Kind::APPLY, {_e692, _e682});
  _e694 = mkExprInternal(Kind::APPLY, {_e693, _e691});
  _e695 = mkExprInternal(Kind::APPLY, {_e51, _e694});
  _e696 = mkExprInternal(Kind::PROOF_TYPE, {_e695});
  _e697 = mkExprInternal(Kind::FUNCTION_TYPE, {_e696, _e690});
  _e681 = mkSymbolInternal(Kind::PROOF_RULE, "not_ite_elim1", _e697);
  bind("not_ite_elim1", _e681);
  _runId[_e697.get()] = 697;
  _e697->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e699 = mkSymbolInternal(Kind::PARAM, "F2", _e42);
  _e700 = mkExprInternal(Kind::APPLY, {_e51, _e699});
  _e701 = mkExprInternal(Kind::APPLY, {_e57, _e700});
  _e702 = mkExprInternal(Kind::APPLY, {_e701, _e258});
  _e703 = mkSymbolInternal(Kind::PARAM, "C", _e42);
  _e704 = mkExprInternal(Kind::APPLY, {_e57, _e703});
  _e705 = mkExprInternal(Kind::APPLY, {_e704, _e702});
  _e706 = mkExprInternal(Kind::PROOF_TYPE, {_e705});
  _e707 = mkSymbolInternal(Kind::PARAM, "F1", _e42);
  _e708 = mkExprInternal(Kind::APPLY, {_e46, _e703});
  _e709 = mkExprInternal(Kind::APPLY, {_e708, _e707});
  _e710 = mkExprInternal(Kind::APPLY, {_e709, _e699});
  _e711 = mkExprInternal(Kind::APPLY, {_e51, _e710});
  _e712 = mkExprInternal(Kind::PROOF_TYPE, {_e711});
  _e713 = mkExprInternal(Kind::FUNCTION_TYPE, {_e712, _e706});
  _e698 = mkSymbolInternal(Kind::PROOF_RULE, "not_ite_elim2", _e713);
  bind("not_ite_elim2", _e698);
  _runId[_e713.get()] = 713;
  _e713->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e714 = mkSymbolInternal(Kind::PROGRAM_CONST, "lowerNotAnd", _e52);
  _runId[_e714.get()] = 714;
  _e714->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e715 = mkSymbolInternal(Kind::PARAM, "l", _e42);
  _e716 = mkExprInternal(Kind::APPLY, {_e51, _e715});
  _runId[_e716.get()] = 716;
  _e716->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e717 = mkSymbolInternal(Kind::PARAM, "ls", _e42);
  _e718 = mkExprInternal(Kind::APPLY, {_e714, _e717});
  _e719 = mkExprInternal(Kind::APPLY, {_e245, _e716, _e718});
  bind("lowerNotAnd", _e714);
  _e721 = mkSymbolInternal(Kind::PARAM, "F", _e42);
  _e722 = mkExprInternal(Kind::APPLY, {_e714, _e721});
  _e723 = mkExprInternal(Kind::PROOF_TYPE, {_e722});
  _e724 = mkExprInternal(Kind::APPLY, {_e51, _e721});
  _e725 = mkExprInternal(Kind::PROOF_TYPE, {_e724});
  _e726 = mkExprInternal(Kind::FUNCTION_TYPE, {_e725, _e723});
  _e720 = mkSymbolInternal(Kind::PROOF_RULE, "not_and", _e726);
  bind("not_and", _e720);
  _runId[_e726.get()] = 726;
  _e726->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e728 = mkSymbolInternal(Kind::PARAM, "Fs", _e42);
  _e729 = mkSymbolInternal(Kind::PARAM, "i", _e95);
  _e730 = mkExprInternal(Kind::APPLY, {_e210, _e59, _e729, _e728});
  _e731 = mkExprInternal(Kind::APPLY, {_e57, _e730});
  _e732 = mkExprInternal(Kind::APPLY, {_e731, _e258});
  _e733 = mkExprInternal(Kind::APPLY, {_e51, _e728});
  _e733->d_type = _e42;
  _e734 = mkExprInternal(Kind::APPLY, {_e57, _e733});
  _e735 = mkExprInternal(Kind::APPLY, {_e734, _e732});
  _e736 = mkExprInternal(Kind::PROOF_TYPE, {_e735});
  _e737 = mkExprInternal(Kind::QUOTE_TYPE, {_e729});
  _e738 = mkExprInternal(Kind::QUOTE_TYPE, {_e728});
  _e739 = mkExprInternal(Kind::FUNCTION_TYPE, {_e738, _e737, _e736});
  _e727 = mkSymbolInternal(Kind::PROOF_RULE, "cnf_and_pos", _e739);
  bind("cnf_and_pos", _e727);
  _runId[_e739.get()] = 739;
  _e739->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e741 = mkSymbolInternal(Kind::PARAM, "Fs", _e42);
  _e742 = mkExprInternal(Kind::APPLY, {_e714, _e741});
  _e743 = mkExprInternal(Kind::APPLY, {_e245, _e741, _e742});
  _e744 = mkExprInternal(Kind::PROOF_TYPE, {_e743});
  _e745 = mkExprInternal(Kind::QUOTE_TYPE, {_e741});
  _e746 = mkExprInternal(Kind::FUNCTION_TYPE, {_e745, _e744});
  _e740 = mkSymbolInternal(Kind::PROOF_RULE, "cnf_and_neg", _e746);
  bind("cnf_and_neg", _e740);
  _runId[_e746.get()] = 746;
  _e746->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e748 = mkSymbolInternal(Kind::PARAM, "Fs", _e42);
  _e749 = mkExprInternal(Kind::APPLY, {_e51, _e748});
  _e750 = mkExprInternal(Kind::APPLY, {_e245, _e749, _e748});
  _e751 = mkExprInternal(Kind::PROOF_TYPE, {_e750});
  _e752 = mkExprInternal(Kind::QUOTE_TYPE, {_e748});
  _e753 = mkExprInternal(Kind::FUNCTION_TYPE, {_e752, _e751});
  _e747 = mkSymbolInternal(Kind::PROOF_RULE, "cnf_or_pos", _e753);
  bind("cnf_or_pos", _e747);
  _runId[_e753.get()] = 753;
  _e753->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e755 = mkSymbolInternal(Kind::PARAM, "Fs", _e42);
  _e756 = mkSymbolInternal(Kind::PARAM, "i", _e95);
  _e757 = mkExprInternal(Kind::APPLY, {_e210, _e57, _e756, _e755});
  _e758 = mkExprInternal(Kind::APPLY, {_e51, _e757});
  _e759 = mkExprInternal(Kind::APPLY, {_e245, _e758, _e258});
  _e760 = mkExprInternal(Kind::APPLY, {_e249, _e755, _e759});
  _e761 = mkExprInternal(Kind::PROOF_TYPE, {_e760});
  _e762 = mkExprInternal(Kind::QUOTE_TYPE, {_e756});
  _e763 = mkExprInternal(Kind::QUOTE_TYPE, {_e755});
  _e764 = mkExprInternal(Kind::FUNCTION_TYPE, {_e763, _e762, _e761});
  _e754 = mkSymbolInternal(Kind::PROOF_RULE, "cnf_or_neg", _e764);
  bind("cnf_or_neg", _e754);
  _runId[_e764.get()] = 764;
  _e764->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e766 = mkSymbolInternal(Kind::PARAM, "F2", _e42);
  _e767 = mkExprInternal(Kind::APPLY, {_e57, _e766});
  _e768 = mkExprInternal(Kind::APPLY, {_e767, _e258});
  _e769 = mkSymbolInternal(Kind::PARAM, "F1", _e42);
  _e770 = mkExprInternal(Kind::APPLY, {_e51, _e769});
  _e771 = mkExprInternal(Kind::APPLY, {_e57, _e770});
  _e772 = mkExprInternal(Kind::APPLY, {_e771, _e768});
  _e773 = mkExprInternal(Kind::APPLY, {_e60, _e769});
  _e773->d_type = _e52;
  _e774 = mkExprInternal(Kind::APPLY, {_e773, _e766});
  _e774->d_type = _e42;
  _e775 = mkExprInternal(Kind::APPLY, {_e51, _e774});
  _e775->d_type = _e42;
  _e776 = mkExprInternal(Kind::APPLY, {_e57, _e775});
  _e777 = mkExprInternal(Kind::APPLY, {_e776, _e772});
  _e778 = mkExprInternal(Kind::PROOF_TYPE, {_e777});
  _e779 = mkExprInternal(Kind::QUOTE_TYPE, {_e774});
  _e780 = mkExprInternal(Kind::FUNCTION_TYPE, {_e779, _e778});
  _e765 = mkSymbolInternal(Kind::PROOF_RULE, "cnf_implies_pos", _e780);
  bind("cnf_implies_pos", _e765);
  _runId[_e780.get()] = 780;
  _e780->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e782 = mkSymbolInternal(Kind::PARAM, "F1", _e42);
  _e783 = mkExprInternal(Kind::APPLY, {_e57, _e782});
  _e784 = mkExprInternal(Kind::APPLY, {_e783, _e258});
  _e785 = mkSymbolInternal(Kind::PARAM, "F2", _e42);
  _e786 = mkExprInternal(Kind::APPLY, {_e60, _e782});
  _e786->d_type = _e52;
  _e787 = mkExprInternal(Kind::APPLY, {_e786, _e785});
  _e787->d_type = _e42;
  _e788 = mkExprInternal(Kind::APPLY, {_e57, _e787});
  _e789 = mkExprInternal(Kind::APPLY, {_e788, _e784});
  _e790 = mkExprInternal(Kind::PROOF_TYPE, {_e789});
  _e791 = mkExprInternal(Kind::QUOTE_TYPE, {_e787});
  _e792 = mkExprInternal(Kind::FUNCTION_TYPE, {_e791, _e790});
  _e781 = mkSymbolInternal(Kind::PROOF_RULE, "cnf_implies_neg1", _e792);
  bind("cnf_implies_neg1", _e781);
  _runId[_e792.get()] = 792;
  _e792->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e794 = mkSymbolInternal(Kind::PARAM, "F2", _e42);
  _e795 = mkExprInternal(Kind::APPLY, {_e51, _e794});
  _e796 = mkExprInternal(Kind::APPLY, {_e57, _e795});
  _e797 = mkExprInternal(Kind::APPLY, {_e796, _e258});
  _e798 = mkSymbolInternal(Kind::PARAM, "F1", _e42);
  _e799 = mkExprInternal(Kind::APPLY, {_e60, _e798});
  _e799->d_type = _e52;
  _e800 = mkExprInternal(Kind::APPLY, {_e799, _e794});
  _e800->d_type = _e42;
  _e801 = mkExprInternal(Kind::APPLY, {_e57, _e800});
  _e802 = mkExprInternal(Kind::APPLY, {_e801, _e797});
  _e803 = mkExprInternal(Kind::PROOF_TYPE, {_e802});
  _e804 = mkExprInternal(Kind::QUOTE_TYPE, {_e800});
  _e805 = mkExprInternal(Kind::FUNCTION_TYPE, {_e804, _e803});
  _e793 = mkSymbolInternal(Kind::PROOF_RULE, "cnf_implies_neg2", _e805);
  bind("cnf_implies_neg2", _e793);
  _runId[_e805.get()] = 805;
  _e805->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e807 = mkSymbolInternal(Kind::PARAM, "F2", _e42);
  _e808 = mkExprInternal(Kind::APPLY, {_e57, _e807});
  _e809 = mkExprInternal(Kind::APPLY, {_e808, _e258});
  _e810 = mkSymbolInternal(Kind::PARAM, "F1", _e42);
  _e811 = mkExprInternal(Kind::APPLY, {_e51, _e810});
  _e812 = mkExprInternal(Kind::APPLY, {_e57, _e811});
  _e813 = mkExprInternal(Kind::APPLY, {_e812, _e809});
  _e814 = mkExprInternal(Kind::APPLY, {_e62, _e810});
  _e814->d_type = _e52;
  _e815 = mkExprInternal(Kind::APPLY, {_e814, _e807});
  _e815->d_type = _e42;
  _e816 = mkExprInternal(Kind::APPLY, {_e51, _e815});
  _e816->d_type = _e42;
  _e817 = mkExprInternal(Kind::APPLY, {_e57, _e816});
  _e818 = mkExprInternal(Kind::APPLY, {_e817, _e813});
  _e819 = mkExprInternal(Kind::PROOF_TYPE, {_e818});
  _e820 = mkExprInternal(Kind::QUOTE_TYPE, {_e815});
  _e821 = mkExprInternal(Kind::FUNCTION_TYPE, {_e820, _e819});
  _e806 = mkSymbolInternal(Kind::PROOF_RULE, "cnf_equiv_pos1", _e821);
  bind("cnf_equiv_pos1", _e806);
  _runId[_e821.get()] = 821;
  _e821->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e823 = mkSymbolInternal(Kind::PARAM, "F2", _e42);
  _e824 = mkExprInternal(Kind::APPLY, {_e51, _e823});
  _e825 = mkExprInternal(Kind::APPLY, {_e57, _e824});
  _e826 = mkExprInternal(Kind::APPLY, {_e825, _e258});
  _e827 = mkSymbolInternal(Kind::PARAM, "F1", _e42);
  _e828 = mkExprInternal(Kind::APPLY, {_e57, _e827});
  _e829 = mkExprInternal(Kind::APPLY, {_e828, _e826});
  _e830 = mkExprInternal(Kind::APPLY, {_e62, _e827});
  _e830->d_type = _e52;
  _e831 = mkExprInternal(Kind::APPLY, {_e830, _e823});
  _e831->d_type = _e42;
  _e832 = mkExprInternal(Kind::APPLY, {_e51, _e831});
  _e832->d_type = _e42;
  _e833 = mkExprInternal(Kind::APPLY, {_e57, _e832});
  _e834 = mkExprInternal(Kind::APPLY, {_e833, _e829});
  _e835 = mkExprInternal(Kind::PROOF_TYPE, {_e834});
  _e836 = mkExprInternal(Kind::QUOTE_TYPE, {_e831});
  _e837 = mkExprInternal(Kind::FUNCTION_TYPE, {_e836, _e835});
  _e822 = mkSymbolInternal(Kind::PROOF_RULE, "cnf_equiv_pos2", _e837);
  bind("cnf_equiv_pos2", _e822);
  _runId[_e837.get()] = 837;
  _e837->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e839 = mkSymbolInternal(Kind::PARAM, "F2", _e42);
  _e840 = mkExprInternal(Kind::APPLY, {_e57, _e839});
  _e841 = mkExprInternal(Kind::APPLY, {_e840, _e258});
  _e842 = mkSymbolInternal(Kind::PARAM, "F1", _e42);
  _e843 = mkExprInternal(Kind::APPLY, {_e57, _e842});
  _e844 = mkExprInternal(Kind::APPLY, {_e843, _e841});
  _e845 = mkExprInternal(Kind::APPLY, {_e62, _e842});
  _e845->d_type = _e52;
  _e846 = mkExprInternal(Kind::APPLY, {_e845, _e839});
  _e846->d_type = _e42;
  _e847 = mkExprInternal(Kind::APPLY, {_e57, _e846});
  _e848 = mkExprInternal(Kind::APPLY, {_e847, _e844});
  _e849 = mkExprInternal(Kind::PROOF_TYPE, {_e848});
  _e850 = mkExprInternal(Kind::QUOTE_TYPE, {_e846});
  _e851 = mkExprInternal(Kind::FUNCTION_TYPE, {_e850, _e849});
  _e838 = mkSymbolInternal(Kind::PROOF_RULE, "cnf_equiv_neg1", _e851);
  bind("cnf_equiv_neg1", _e838);
  _runId[_e851.get()] = 851;
  _e851->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e853 = mkSymbolInternal(Kind::PARAM, "F2", _e42);
  _e854 = mkExprInternal(Kind::APPLY, {_e51, _e853});
  _e855 = mkExprInternal(Kind::APPLY, {_e57, _e854});
  _e856 = mkExprInternal(Kind::APPLY, {_e855, _e258});
  _e857 = mkSymbolInternal(Kind::PARAM, "F1", _e42);
  _e858 = mkExprInternal(Kind::APPLY, {_e51, _e857});
  _e859 = mkExprInternal(Kind::APPLY, {_e57, _e858});
  _e860 = mkExprInternal(Kind::APPLY, {_e859, _e856});
  _e861 = mkExprInternal(Kind::APPLY, {_e62, _e857});
  _e861->d_type = _e52;
  _e862 = mkExprInternal(Kind::APPLY, {_e861, _e853});
  _e862->d_type = _e42;
  _e863 = mkExprInternal(Kind::APPLY, {_e57, _e862});
  _e864 = mkExprInternal(Kind::APPLY, {_e863, _e860});
  _e865 = mkExprInternal(Kind::PROOF_TYPE, {_e864});
  _e866 = mkExprInternal(Kind::QUOTE_TYPE, {_e862});
  _e867 = mkExprInternal(Kind::FUNCTION_TYPE, {_e866, _e865});
  _e852 = mkSymbolInternal(Kind::PROOF_RULE, "cnf_equiv_neg2", _e867);
  bind("cnf_equiv_neg2", _e852);
  _runId[_e867.get()] = 867;
  _e867->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e869 = mkSymbolInternal(Kind::PARAM, "F2", _e42);
  _e870 = mkExprInternal(Kind::APPLY, {_e57, _e869});
  _e871 = mkExprInternal(Kind::APPLY, {_e870, _e258});
  _e872 = mkSymbolInternal(Kind::PARAM, "F1", _e42);
  _e873 = mkExprInternal(Kind::APPLY, {_e57, _e872});
  _e874 = mkExprInternal(Kind::APPLY, {_e873, _e871});
  _e875 = mkExprInternal(Kind::APPLY, {_e61, _e872});
  _e875->d_type = _e52;
  _e876 = mkExprInternal(Kind::APPLY, {_e875, _e869});
  _e876->d_type = _e42;
  _e877 = mkExprInternal(Kind::APPLY, {_e51, _e876});
  _e877->d_type = _e42;
  _e878 = mkExprInternal(Kind::APPLY, {_e57, _e877});
  _e879 = mkExprInternal(Kind::APPLY, {_e878, _e874});
  _e880 = mkExprInternal(Kind::PROOF_TYPE, {_e879});
  _e881 = mkExprInternal(Kind::QUOTE_TYPE, {_e876});
  _e882 = mkExprInternal(Kind::FUNCTION_TYPE, {_e881, _e880});
  _e868 = mkSymbolInternal(Kind::PROOF_RULE, "cnf_xor_pos1", _e882);
  bind("cnf_xor_pos1", _e868);
  _runId[_e882.get()] = 882;
  _e882->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e884 = mkSymbolInternal(Kind::PARAM, "F2", _e42);
  _e885 = mkExprInternal(Kind::APPLY, {_e51, _e884});
  _e886 = mkExprInternal(Kind::APPLY, {_e57, _e885});
  _e887 = mkExprInternal(Kind::APPLY, {_e886, _e258});
  _e888 = mkSymbolInternal(Kind::PARAM, "F1", _e42);
  _e889 = mkExprInternal(Kind::APPLY, {_e51, _e888});
  _e890 = mkExprInternal(Kind::APPLY, {_e57, _e889});
  _e891 = mkExprInternal(Kind::APPLY, {_e890, _e887});
  _e892 = mkExprInternal(Kind::APPLY, {_e61, _e888});
  _e892->d_type = _e52;
  _e893 = mkExprInternal(Kind::APPLY, {_e892, _e884});
  _e893->d_type = _e42;
  _e894 = mkExprInternal(Kind::APPLY, {_e51, _e893});
  _e894->d_type = _e42;
  _e895 = mkExprInternal(Kind::APPLY, {_e57, _e894});
  _e896 = mkExprInternal(Kind::APPLY, {_e895, _e891});
  _e897 = mkExprInternal(Kind::PROOF_TYPE, {_e896});
  _e898 = mkExprInternal(Kind::QUOTE_TYPE, {_e893});
  _e899 = mkExprInternal(Kind::FUNCTION_TYPE, {_e898, _e897});
  _e883 = mkSymbolInternal(Kind::PROOF_RULE, "cnf_xor_pos2", _e899);
  bind("cnf_xor_pos2", _e883);
  _runId[_e899.get()] = 899;
  _e899->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e901 = mkSymbolInternal(Kind::PARAM, "F2", _e42);
  _e902 = mkExprInternal(Kind::APPLY, {_e57, _e901});
  _e903 = mkExprInternal(Kind::APPLY, {_e902, _e258});
  _e904 = mkSymbolInternal(Kind::PARAM, "F1", _e42);
  _e905 = mkExprInternal(Kind::APPLY, {_e51, _e904});
  _e906 = mkExprInternal(Kind::APPLY, {_e57, _e905});
  _e907 = mkExprInternal(Kind::APPLY, {_e906, _e903});
  _e908 = mkExprInternal(Kind::APPLY, {_e61, _e904});
  _e908->d_type = _e52;
  _e909 = mkExprInternal(Kind::APPLY, {_e908, _e901});
  _e909->d_type = _e42;
  _e910 = mkExprInternal(Kind::APPLY, {_e57, _e909});
  _e911 = mkExprInternal(Kind::APPLY, {_e910, _e907});
  _e912 = mkExprInternal(Kind::PROOF_TYPE, {_e911});
  _e913 = mkExprInternal(Kind::QUOTE_TYPE, {_e909});
  _e914 = mkExprInternal(Kind::FUNCTION_TYPE, {_e913, _e912});
  _e900 = mkSymbolInternal(Kind::PROOF_RULE, "cnf_xor_neg1", _e914);
  bind("cnf_xor_neg1", _e900);
  _runId[_e914.get()] = 914;
  _e914->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e916 = mkSymbolInternal(Kind::PARAM, "F2", _e42);
  _e917 = mkExprInternal(Kind::APPLY, {_e51, _e916});
  _e918 = mkExprInternal(Kind::APPLY, {_e57, _e917});
  _e919 = mkExprInternal(Kind::APPLY, {_e918, _e258});
  _e920 = mkSymbolInternal(Kind::PARAM, "F1", _e42);
  _e921 = mkExprInternal(Kind::APPLY, {_e57, _e920});
  _e922 = mkExprInternal(Kind::APPLY, {_e921, _e919});
  _e923 = mkExprInternal(Kind::APPLY, {_e61, _e920});
  _e923->d_type = _e52;
  _e924 = mkExprInternal(Kind::APPLY, {_e923, _e916});
  _e924->d_type = _e42;
  _e925 = mkExprInternal(Kind::APPLY, {_e57, _e924});
  _e926 = mkExprInternal(Kind::APPLY, {_e925, _e922});
  _e927 = mkExprInternal(Kind::PROOF_TYPE, {_e926});
  _e928 = mkExprInternal(Kind::QUOTE_TYPE, {_e924});
  _e929 = mkExprInternal(Kind::FUNCTION_TYPE, {_e928, _e927});
  _e915 = mkSymbolInternal(Kind::PROOF_RULE, "cnf_xor_neg2", _e929);
  bind("cnf_xor_neg2", _e915);
  _runId[_e929.get()] = 929;
  _e929->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e931 = mkSymbolInternal(Kind::PARAM, "F1", _e42);
  _e932 = mkExprInternal(Kind::APPLY, {_e57, _e931});
  _e933 = mkExprInternal(Kind::APPLY, {_e932, _e258});
  _e934 = mkSymbolInternal(Kind::PARAM, "C", _e42);
  _e935 = mkExprInternal(Kind::APPLY, {_e51, _e934});
  _e936 = mkExprInternal(Kind::APPLY, {_e57, _e935});
  _e937 = mkExprInternal(Kind::APPLY, {_e936, _e933});
  _e938 = mkSymbolInternal(Kind::PARAM, "F2", _e42);
  _e939 = mkExprInternal(Kind::APPLY, {_e46, _e934});
  _e939->d_type = _e49;
  _e940 = mkExprInternal(Kind::APPLY, {_e939, _e931});
  _e940->d_type = _e52;
  _e941 = mkExprInternal(Kind::APPLY, {_e940, _e938});
  _e941->d_type = _e42;
  _e942 = mkExprInternal(Kind::APPLY, {_e51, _e941});
  _e942->d_type = _e42;
  _e943 = mkExprInternal(Kind::APPLY, {_e57, _e942});
  _e944 = mkExprInternal(Kind::APPLY, {_e943, _e937});
  _e945 = mkExprInternal(Kind::PROOF_TYPE, {_e944});
  _e946 = mkExprInternal(Kind::QUOTE_TYPE, {_e941});
  _e947 = mkExprInternal(Kind::FUNCTION_TYPE, {_e946, _e945});
  _e930 = mkSymbolInternal(Kind::PROOF_RULE, "cnf_ite_pos1", _e947);
  bind("cnf_ite_pos1", _e930);
  _runId[_e947.get()] = 947;
  _e947->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e949 = mkSymbolInternal(Kind::PARAM, "F2", _e42);
  _e950 = mkExprInternal(Kind::APPLY, {_e57, _e949});
  _e951 = mkExprInternal(Kind::APPLY, {_e950, _e258});
  _e952 = mkSymbolInternal(Kind::PARAM, "C", _e42);
  _e953 = mkExprInternal(Kind::APPLY, {_e57, _e952});
  _e954 = mkExprInternal(Kind::APPLY, {_e953, _e951});
  _e955 = mkSymbolInternal(Kind::PARAM, "F1", _e42);
  _e956 = mkExprInternal(Kind::APPLY, {_e46, _e952});
  _e956->d_type = _e49;
  _e957 = mkExprInternal(Kind::APPLY, {_e956, _e955});
  _e957->d_type = _e52;
  _e958 = mkExprInternal(Kind::APPLY, {_e957, _e949});
  _e958->d_type = _e42;
  _e959 = mkExprInternal(Kind::APPLY, {_e51, _e958});
  _e959->d_type = _e42;
  _e960 = mkExprInternal(Kind::APPLY, {_e57, _e959});
  _e961 = mkExprInternal(Kind::APPLY, {_e960, _e954});
  _e962 = mkExprInternal(Kind::PROOF_TYPE, {_e961});
  _e963 = mkExprInternal(Kind::QUOTE_TYPE, {_e958});
  _e964 = mkExprInternal(Kind::FUNCTION_TYPE, {_e963, _e962});
  _e948 = mkSymbolInternal(Kind::PROOF_RULE, "cnf_ite_pos2", _e964);
  bind("cnf_ite_pos2", _e948);
  _runId[_e964.get()] = 964;
  _e964->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e966 = mkSymbolInternal(Kind::PARAM, "F2", _e42);
  _e967 = mkExprInternal(Kind::APPLY, {_e57, _e966});
  _e968 = mkExprInternal(Kind::APPLY, {_e967, _e258});
  _e969 = mkSymbolInternal(Kind::PARAM, "F1", _e42);
  _e970 = mkExprInternal(Kind::APPLY, {_e57, _e969});
  _e971 = mkExprInternal(Kind::APPLY, {_e970, _e968});
  _e972 = mkSymbolInternal(Kind::PARAM, "C", _e42);
  _e973 = mkExprInternal(Kind::APPLY, {_e46, _e972});
  _e973->d_type = _e49;
  _e974 = mkExprInternal(Kind::APPLY, {_e973, _e969});
  _e974->d_type = _e52;
  _e975 = mkExprInternal(Kind::APPLY, {_e974, _e966});
  _e975->d_type = _e42;
  _e976 = mkExprInternal(Kind::APPLY, {_e51, _e975});
  _e976->d_type = _e42;
  _e977 = mkExprInternal(Kind::APPLY, {_e57, _e976});
  _e978 = mkExprInternal(Kind::APPLY, {_e977, _e971});
  _e979 = mkExprInternal(Kind::PROOF_TYPE, {_e978});
  _e980 = mkExprInternal(Kind::QUOTE_TYPE, {_e975});
  _e981 = mkExprInternal(Kind::FUNCTION_TYPE, {_e980, _e979});
  _e965 = mkSymbolInternal(Kind::PROOF_RULE, "cnf_ite_pos3", _e981);
  bind("cnf_ite_pos3", _e965);
  _runId[_e981.get()] = 981;
  _e981->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e983 = mkSymbolInternal(Kind::PARAM, "F1", _e42);
  _e984 = mkExprInternal(Kind::APPLY, {_e51, _e983});
  _e985 = mkExprInternal(Kind::APPLY, {_e57, _e984});
  _e986 = mkExprInternal(Kind::APPLY, {_e985, _e258});
  _e987 = mkSymbolInternal(Kind::PARAM, "C", _e42);
  _e988 = mkExprInternal(Kind::APPLY, {_e51, _e987});
  _e989 = mkExprInternal(Kind::APPLY, {_e57, _e988});
  _e990 = mkExprInternal(Kind::APPLY, {_e989, _e986});
  _e991 = mkSymbolInternal(Kind::PARAM, "F2", _e42);
  _e992 = mkExprInternal(Kind::APPLY, {_e46, _e987});
  _e992->d_type = _e49;
  _e993 = mkExprInternal(Kind::APPLY, {_e992, _e983});
  _e993->d_type = _e52;
  _e994 = mkExprInternal(Kind::APPLY, {_e993, _e991});
  _e994->d_type = _e42;
  _e995 = mkExprInternal(Kind::APPLY, {_e57, _e994});
  _e996 = mkExprInternal(Kind::APPLY, {_e995, _e990});
  _e997 = mkExprInternal(Kind::PROOF_TYPE, {_e996});
  _e998 = mkExprInternal(Kind::QUOTE_TYPE, {_e994});
  _e999 = mkExprInternal(Kind::FUNCTION_TYPE, {_e998, _e997});
  _e982 = mkSymbolInternal(Kind::PROOF_RULE, "cnf_ite_neg1", _e999);
  bind("cnf_ite_neg1", _e982);
  _runId[_e999.get()] = 999;
  _e999->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1001 = mkSymbolInternal(Kind::PARAM, "F2", _e42);
  _e1002 = mkExprInternal(Kind::APPLY, {_e51, _e1001});
  _e1003 = mkExprInternal(Kind::APPLY, {_e57, _e1002});
  _e1004 = mkExprInternal(Kind::APPLY, {_e1003, _e258});
  _e1005 = mkSymbolInternal(Kind::PARAM, "C", _e42);
  _e1006 = mkExprInternal(Kind::APPLY, {_e57, _e1005});
  _e1007 = mkExprInternal(Kind::APPLY, {_e1006, _e1004});
  _e1008 = mkSymbolInternal(Kind::PARAM, "F1", _e42);
  _e1009 = mkExprInternal(Kind::APPLY, {_e46, _e1005});
  _e1009->d_type = _e49;
  _e1010 = mkExprInternal(Kind::APPLY, {_e1009, _e1008});
  _e1010->d_type = _e52;
  _e1011 = mkExprInternal(Kind::APPLY, {_e1010, _e1001});
  _e1011->d_type = _e42;
  _e1012 = mkExprInternal(Kind::APPLY, {_e57, _e1011});
  _e1013 = mkExprInternal(Kind::APPLY, {_e1012, _e1007});
  _e1014 = mkExprInternal(Kind::PROOF_TYPE, {_e1013});
  _e1015 = mkExprInternal(Kind::QUOTE_TYPE, {_e1011});
  _e1016 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1015, _e1014});
  _e1000 = mkSymbolInternal(Kind::PROOF_RULE, "cnf_ite_neg2", _e1016);
  bind("cnf_ite_neg2", _e1000);
  _runId[_e1016.get()] = 1016;
  _e1016->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1018 = mkSymbolInternal(Kind::PARAM, "F2", _e42);
  _e1019 = mkExprInternal(Kind::APPLY, {_e51, _e1018});
  _e1020 = mkExprInternal(Kind::APPLY, {_e57, _e1019});
  _e1021 = mkExprInternal(Kind::APPLY, {_e1020, _e258});
  _e1022 = mkSymbolInternal(Kind::PARAM, "F1", _e42);
  _e1023 = mkExprInternal(Kind::APPLY, {_e51, _e1022});
  _e1024 = mkExprInternal(Kind::APPLY, {_e57, _e1023});
  _e1025 = mkExprInternal(Kind::APPLY, {_e1024, _e1021});
  _e1026 = mkSymbolInternal(Kind::PARAM, "C", _e42);
  _e1027 = mkExprInternal(Kind::APPLY, {_e46, _e1026});
  _e1027->d_type = _e49;
  _e1028 = mkExprInternal(Kind::APPLY, {_e1027, _e1022});
  _e1028->d_type = _e52;
  _e1029 = mkExprInternal(Kind::APPLY, {_e1028, _e1018});
  _e1029->d_type = _e42;
  _e1030 = mkExprInternal(Kind::APPLY, {_e57, _e1029});
  _e1031 = mkExprInternal(Kind::APPLY, {_e1030, _e1025});
  _e1032 = mkExprInternal(Kind::PROOF_TYPE, {_e1031});
  _e1033 = mkExprInternal(Kind::QUOTE_TYPE, {_e1029});
  _e1034 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1033, _e1032});
  _e1017 = mkSymbolInternal(Kind::PROOF_RULE, "cnf_ite_neg3", _e1034);
  bind("cnf_ite_neg3", _e1017);
  _runId[_e1034.get()] = 1034;
  _e1034->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1036 = mkSymbolInternal(Kind::PARAM, "Fs", _e42);
  _e1037 = mkExprInternal(Kind::PROOF_TYPE, {_e1036});
  _e1038 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1037, _e469});
  _e1035 = mkSymbolInternal(Kind::PROOF_RULE, "sat_refutation", _e1038);
  bind("sat_refutation", _e1035);
  _runId[_e1038.get()] = 1038;
  _e1038->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1041 = mkSymbolInternal(Kind::PARAM, "T", _e2);
  _e1040 = mkSymbolInternal(Kind::PARAM, "t", _e1041);
  _e1042 = mkExprInternal(Kind::APPLY, {_e62, _e1040});
  _e1043 = mkExprInternal(Kind::APPLY, {_e1042, _e1040});
  _e1044 = mkExprInternal(Kind::PROOF_TYPE, {_e1043});
  _e1045 = mkExprInternal(Kind::QUOTE_TYPE, {_e1040});
  _e1046 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1045, _e1044});
  _e1039 = mkSymbolInternal(Kind::PROOF_RULE, "refl", _e1046);
  bind("refl", _e1039);
  _runId[_e1046.get()] = 1046;
  _e1046->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1047 = mkSymbolInternal(Kind::PROGRAM_CONST, "flipEq", _e52);
  _runId[_e1047.get()] = 1047;
  _e1047->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1049 = mkSymbolInternal(Kind::PARAM, "T", _e2);
  _e1048 = mkSymbolInternal(Kind::PARAM, "t1", _e1049);
  _e1050 = mkSymbolInternal(Kind::PARAM, "t2", _e1049);
  _e1051 = mkExprInternal(Kind::APPLY, {_e62, _e1050});
  _e1052 = mkExprInternal(Kind::APPLY, {_e1051, _e1048});
  _runId[_e1052.get()] = 1052;
  _e1052->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1053 = mkExprInternal(Kind::APPLY, {_e51, _e1052});
  _runId[_e1053.get()] = 1053;
  _e1053->setFlag(ExprValue::Flag::IS_COMPILED, true);
  bind("flipEq", _e1047);
  _e1055 = mkSymbolInternal(Kind::PARAM, "F", _e42);
  _e1056 = mkExprInternal(Kind::APPLY, {_e1047, _e1055});
  _e1057 = mkExprInternal(Kind::PROOF_TYPE, {_e1056});
  _e1058 = mkExprInternal(Kind::PROOF_TYPE, {_e1055});
  _e1059 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1058, _e1057});
  _e1054 = mkSymbolInternal(Kind::PROOF_RULE, "symm", _e1059);
  bind("symm", _e1054);
  _runId[_e1059.get()] = 1059;
  _e1059->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1062 = mkSymbolInternal(Kind::PARAM, "T", _e2);
  _e1061 = mkSymbolInternal(Kind::PARAM, "t3", _e1062);
  _e1063 = mkSymbolInternal(Kind::PARAM, "t1", _e1062);
  _e1064 = mkExprInternal(Kind::APPLY, {_e62, _e1063});
  _e1065 = mkExprInternal(Kind::APPLY, {_e1064, _e1061});
  _e1066 = mkExprInternal(Kind::PROOF_TYPE, {_e1065});
  _e1067 = mkSymbolInternal(Kind::PARAM, "t2", _e1062);
  _e1068 = mkExprInternal(Kind::APPLY, {_e62, _e1067});
  _e1069 = mkExprInternal(Kind::APPLY, {_e1068, _e1061});
  _e1070 = mkExprInternal(Kind::PROOF_TYPE, {_e1069});
  _e1071 = mkExprInternal(Kind::APPLY, {_e1064, _e1067});
  _e1072 = mkExprInternal(Kind::PROOF_TYPE, {_e1071});
  _e1073 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1072, _e1070, _e1066});
  _e1060 = mkSymbolInternal(Kind::PROOF_RULE, "trans", _e1073);
  bind("trans", _e1060);
  _runId[_e1073.get()] = 1073;
  _e1073->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1076 = mkSymbolInternal(Kind::PARAM, "T", _e2);
  _e1075 = mkSymbolInternal(Kind::PARAM, "t2", _e1076);
  _e1078 = mkSymbolInternal(Kind::PARAM, "U", _e2);
  _e1079 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1076, _e1078});
  _e1079->d_type = _e2;
  _e1077 = mkSymbolInternal(Kind::PARAM, "f", _e1079);
  _e1080 = mkExprInternal(Kind::APPLY, {_e1077, _e1075});
  _e1081 = mkSymbolInternal(Kind::PARAM, "t1", _e1076);
  _e1082 = mkExprInternal(Kind::APPLY, {_e1077, _e1081});
  _e1083 = mkExprInternal(Kind::APPLY, {_e62, _e1082});
  _e1084 = mkExprInternal(Kind::APPLY, {_e1083, _e1080});
  _e1085 = mkExprInternal(Kind::PROOF_TYPE, {_e1084});
  _e1086 = mkExprInternal(Kind::QUOTE_TYPE, {_e1077});
  _e1087 = mkExprInternal(Kind::APPLY, {_e62, _e1081});
  _e1088 = mkExprInternal(Kind::APPLY, {_e1087, _e1075});
  _e1089 = mkExprInternal(Kind::PROOF_TYPE, {_e1088});
  _e1090 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1089, _e1086, _e1085});
  _e1074 = mkSymbolInternal(Kind::PROOF_RULE, "cong", _e1090);
  bind("cong", _e1074);
  _runId[_e1090.get()] = 1090;
  _e1090->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1092 = mkSymbolInternal(Kind::PARAM, "F", _e42);
  _e1093 = mkExprInternal(Kind::APPLY, {_e62, _e1092});
  _e1094 = mkExprInternal(Kind::APPLY, {_e1093, _e227});
  _e1095 = mkExprInternal(Kind::PROOF_TYPE, {_e1094});
  _e1096 = mkExprInternal(Kind::PROOF_TYPE, {_e1092});
  _e1097 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1096, _e1095});
  _e1091 = mkSymbolInternal(Kind::PROOF_RULE, "true_intro", _e1097);
  bind("true_intro", _e1091);
  _runId[_e1097.get()] = 1097;
  _e1097->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1099 = mkSymbolInternal(Kind::PARAM, "F", _e42);
  _e1100 = mkExprInternal(Kind::PROOF_TYPE, {_e1099});
  _e1101 = mkExprInternal(Kind::APPLY, {_e62, _e1099});
  _e1102 = mkExprInternal(Kind::APPLY, {_e1101, _e227});
  _e1103 = mkExprInternal(Kind::PROOF_TYPE, {_e1102});
  _e1104 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1103, _e1100});
  _e1098 = mkSymbolInternal(Kind::PROOF_RULE, "true_elim", _e1104);
  bind("true_elim", _e1098);
  _runId[_e1104.get()] = 1104;
  _e1104->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1106 = mkSymbolInternal(Kind::PARAM, "F", _e42);
  _e1107 = mkExprInternal(Kind::APPLY, {_e62, _e1106});
  _e1108 = mkExprInternal(Kind::APPLY, {_e1107, _e229});
  _e1109 = mkExprInternal(Kind::PROOF_TYPE, {_e1108});
  _e1110 = mkExprInternal(Kind::APPLY, {_e51, _e1106});
  _e1111 = mkExprInternal(Kind::PROOF_TYPE, {_e1110});
  _e1112 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1111, _e1109});
  _e1105 = mkSymbolInternal(Kind::PROOF_RULE, "false_intro", _e1112);
  bind("false_intro", _e1105);
  _runId[_e1112.get()] = 1112;
  _e1112->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1114 = mkSymbolInternal(Kind::PARAM, "F", _e42);
  _e1115 = mkExprInternal(Kind::APPLY, {_e51, _e1114});
  _e1116 = mkExprInternal(Kind::PROOF_TYPE, {_e1115});
  _e1117 = mkExprInternal(Kind::APPLY, {_e62, _e1114});
  _e1118 = mkExprInternal(Kind::APPLY, {_e1117, _e229});
  _e1119 = mkExprInternal(Kind::PROOF_TYPE, {_e1118});
  _e1120 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1119, _e1116});
  _e1113 = mkSymbolInternal(Kind::PROOF_RULE, "false_elim", _e1120);
  bind("false_elim", _e1113);
  _runId[_e1120.get()] = 1120;
  _e1120->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1123 = mkSymbolInternal(Kind::PARAM, "T", _e2);
  _e1122 = mkSymbolInternal(Kind::PARAM, "t2", _e1123);
  _e1125 = mkSymbolInternal(Kind::PARAM, "U", _e2);
  _e1126 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1123, _e1125});
  _e1126->d_type = _e2;
  _e1124 = mkSymbolInternal(Kind::PARAM, "g", _e1126);
  _e1127 = mkExprInternal(Kind::APPLY, {_e1124, _e1122});
  _e1128 = mkSymbolInternal(Kind::PARAM, "t1", _e1123);
  _e1129 = mkSymbolInternal(Kind::PARAM, "f", _e1126);
  _e1130 = mkExprInternal(Kind::APPLY, {_e1129, _e1128});
  _e1131 = mkExprInternal(Kind::APPLY, {_e62, _e1130});
  _e1132 = mkExprInternal(Kind::APPLY, {_e1131, _e1127});
  _e1133 = mkExprInternal(Kind::PROOF_TYPE, {_e1132});
  _e1134 = mkExprInternal(Kind::APPLY, {_e62, _e1128});
  _e1135 = mkExprInternal(Kind::APPLY, {_e1134, _e1122});
  _e1136 = mkExprInternal(Kind::PROOF_TYPE, {_e1135});
  _e1137 = mkExprInternal(Kind::APPLY, {_e62, _e1129});
  _e1138 = mkExprInternal(Kind::APPLY, {_e1137, _e1124});
  _e1139 = mkExprInternal(Kind::PROOF_TYPE, {_e1138});
  _e1140 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1139, _e1136, _e1133});
  _e1121 = mkSymbolInternal(Kind::PROOF_RULE, "ho_cong", _e1140);
  bind("ho_cong", _e1121);
  _runId[_e1140.get()] = 1140;
  _e1140->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1143 = mkSymbolInternal(Kind::PARAM, "T", _e2);
  _e1142 = mkSymbolInternal(Kind::PARAM, "t_encoded", _e1143);
  _e1144 = mkSymbolInternal(Kind::PARAM, "t", _e1143);
  _e1145 = mkExprInternal(Kind::APPLY, {_e62, _e1144});
  _e1146 = mkExprInternal(Kind::APPLY, {_e1145, _e1142});
  _e1147 = mkExprInternal(Kind::PROOF_TYPE, {_e1146});
  _e1148 = mkExprInternal(Kind::QUOTE_TYPE, {_e1142});
  _e1149 = mkExprInternal(Kind::QUOTE_TYPE, {_e1144});
  _e1150 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1149, _e1148, _e1147});
  _e1141 = mkSymbolInternal(Kind::PROOF_RULE, "ho_app_encode", _e1150);
  bind("ho_app_encode", _e1141);
  _runId[_e1150.get()] = 1150;
  _e1150->setFlag(ExprValue::Flag::IS_COMPILED, true);
}

Expr TypeChecker::run_getTypeInternal(Expr& hdType, const std::vector<Expr>& args, std::ostream* out)
{
  std::map<ExprValue*, size_t>::iterator itr = _runId.find(hdType.get());
  switch(itr->second)
  {
  // type rule for (-> (Quote F) (Quote theory) (Quote method) (Proof F))
  case 39:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  const Expr& a0 = args[0];
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  Expr _p4;
  // assign variables
  _p1 = a0;
  // construct return type
  _p4 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p1});
  return _p4;
  }
  break;
  // type rule for (-> (Quote F) (Proof F))
  case 45:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  Expr _p2;
  // assign variables
  _p1 = a0;
  // construct return type
  _p2 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p1});
  return _p2;
  }
  break;
  // type rule for (-> Bool (-> A (-> A A)))
  case 50:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  // check requirements
  if (!(a0==_e42))
  {
     return nullptr;
  }
  // assign variables
  _p1 = _e47;
  // construct return type
  return _e49;
  }
  break;
  // type rule for (-> A (-> A A))
  case 49:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  Expr _p2;
  // assign variables
  _p1 = a0;
  // construct return type
  _p2 = d_state.mkExprInternal(Kind::FUNCTION_TYPE, {_p1, _p1});
  return _p2;
  }
  break;
  // type rule for (-> Bool Bool)
  case 52:
  {
  const Expr& a0 = args[0];
  // check requirements
  if (!(a0==_e42))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e42;
  }
  break;
  // type rule for (-> A (-> A Bool))
  case 56:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  Expr _p2;
  // assign variables
  _p1 = a0;
  // construct return type
  _p2 = d_state.mkExprInternal(Kind::FUNCTION_TYPE, {_p1, _e42});
  return _p2;
  }
  break;
  // type rule for (-> Bool (-> Bool Bool))
  case 58:
  {
  const Expr& a0 = args[0];
  // check requirements
  if (!(a0==_e42))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e52;
  }
  break;
  // type rule for (-> A (-> A Bool))
  case 65:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  Expr _p2;
  // assign variables
  _p1 = a0;
  // construct return type
  _p2 = d_state.mkExprInternal(Kind::FUNCTION_TYPE, {_p1, _e42});
  return _p2;
  }
  break;
  // type rule for (-> (-> A Bool) Bool)
  case 69:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  Expr& a00 = a0->getChildren()[0];
  // check requirements
  if (!(a0->getKind()==Kind::FUNCTION_TYPE && a01==_e42))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e42;
  }
  break;
  // type rule for (-> (-> A Bool) Bool)
  case 73:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  Expr& a00 = a0->getChildren()[0];
  // check requirements
  if (!(a0->getKind()==Kind::FUNCTION_TYPE && a01==_e42))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e42;
  }
  break;
  // type rule for (-> (-> A Bool) A)
  case 77:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  Expr& a00 = a0->getChildren()[0];
  // check requirements
  if (!(a0->getKind()==Kind::FUNCTION_TYPE && a01==_e42))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a00;
  // construct return type
  return _p1;
  }
  break;
  // type rule for (-> (-> B C) (-> (-> A B) (-> A C)))
  case 86:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  Expr& a00 = a0->getChildren()[0];
  Expr _p4;
  Expr _p5;
  Expr _p6;
  // check requirements
  if (!(a0->getKind()==Kind::FUNCTION_TYPE))
  {
     return nullptr;
  }
  // assign variables
  _p3 = a00;
  _p1 = a01;
  _p2 = _e80;
  // construct return type
  _p4 = d_state.mkExprInternal(Kind::FUNCTION_TYPE, {_p2, _p1});
  _p5 = d_state.mkExprInternal(Kind::FUNCTION_TYPE, {_p2, _p3});
  _p6 = d_state.mkExprInternal(Kind::FUNCTION_TYPE, {_p5, _p4});
  return _p6;
  }
  break;
  // type rule for (-> A A)
  case 89:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  // assign variables
  _p1 = a0;
  // construct return type
  return _p1;
  }
  break;
  // type rule for (let ((_v0 (-> A B))) (-> _v0 _v0))
  case 94:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  Expr& a00 = a0->getChildren()[0];
  Expr _p3;
  // check requirements
  if (!(a0->getKind()==Kind::FUNCTION_TYPE))
  {
     return nullptr;
  }
  // assign variables
  _p2 = a00;
  _p1 = a01;
  // construct return type
  _p3 = d_state.mkExprInternal(Kind::FUNCTION_TYPE, {_p2, _p1});
  return _p3;
  }
  break;
  // type rule for (-> Real Int)
  case 98:
  {
  const Expr& a0 = args[0];
  // check requirements
  if (!(a0==_e96))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e95;
  }
  break;
  // type rule for (-> Int Real)
  case 100:
  {
  const Expr& a0 = args[0];
  // check requirements
  if (!(a0==_e95))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e96;
  }
  break;
  // type rule for (-> Int Int)
  case 102:
  {
  const Expr& a0 = args[0];
  // check requirements
  if (!(a0==_e95))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e95;
  }
  break;
  // type rule for (-> Int (-> Int Bool))
  case 106:
  {
  const Expr& a0 = args[0];
  // check requirements
  if (!(a0==_e95))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e105;
  }
  break;
  // type rule for (-> Int Bool)
  case 105:
  {
  const Expr& a0 = args[0];
  // check requirements
  if (!(a0==_e95))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e42;
  }
  break;
  // type rule for (-> Int (-> Int Int))
  case 111:
  {
  const Expr& a0 = args[0];
  // check requirements
  if (!(a0==_e95))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e102;
  }
  break;
  // type rule for (-> Int (-> (Quote n) Int))
  case 119:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  // check requirements
  if (!(a0==_e95))
  {
     return nullptr;
  }
  // assign variables
  _p1 = _e116;
  // construct return type
  return _e118;
  }
  break;
  // type rule for (-> (Quote n) Int)
  case 118:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  // assign variables
  // construct return type
  return _e95;
  }
  break;
  // type rule for (-> Int (-> (Quote n) Bool))
  case 125:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  // check requirements
  if (!(a0==_e95))
  {
     return nullptr;
  }
  // assign variables
  _p1 = _e122;
  // construct return type
  return _e124;
  }
  break;
  // type rule for (-> (Quote n) Bool)
  case 124:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  // assign variables
  // construct return type
  return _e42;
  }
  break;
  // type rule for (-> Int (-> Int (-> (-> Int Int) Int)))
  case 129:
  {
  const Expr& a0 = args[0];
  // check requirements
  if (!(a0==_e95))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e128;
  }
  break;
  // type rule for (-> Int (-> (-> Int Int) Int))
  case 128:
  {
  const Expr& a0 = args[0];
  // check requirements
  if (!(a0==_e95))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e127;
  }
  break;
  // type rule for (-> (-> Int Int) Int)
  case 127:
  {
  const Expr& a0 = args[0];
  // check requirements
  if (!(a0==_e102))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e95;
  }
  break;
  // type rule for (-> U U S S S)
  case 133:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  // check requirements
  if (!(a1==a0 && a3==a2))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a2;
  // construct return type
  return _p1;
  }
  break;
  // type rule for (-> (-> L (-> L L)) L L L)
  case 140:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  if(a01->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a011 = a01->getChildren()[1];
  Expr& a010 = a01->getChildren()[0];
  Expr& a00 = a0->getChildren()[0];
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a0->getKind()==Kind::FUNCTION_TYPE && a01->getKind()==Kind::FUNCTION_TYPE && a010==a011 && a00==a011 && a1==a011 && a2==a011))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a011;
  // construct return type
  return _p1;
  }
  break;
  // type rule for (-> (-> L (-> L L)) L L L)
  case 150:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  if(a01->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a011 = a01->getChildren()[1];
  Expr& a010 = a01->getChildren()[0];
  Expr& a00 = a0->getChildren()[0];
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a0->getKind()==Kind::FUNCTION_TYPE && a01->getKind()==Kind::FUNCTION_TYPE && a010==a011 && a00==a011 && a1==a011 && a2==a011))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a011;
  // construct return type
  return _p1;
  }
  break;
  // type rule for (-> (-> L (-> L L)) L L L)
  case 161:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  if(a01->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a011 = a01->getChildren()[1];
  Expr& a010 = a01->getChildren()[0];
  Expr& a00 = a0->getChildren()[0];
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a0->getKind()==Kind::FUNCTION_TYPE && a01->getKind()==Kind::FUNCTION_TYPE && a010==a011 && a00==a011 && a1==a011 && a2==a011))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a011;
  // construct return type
  return _p1;
  }
  break;
  // type rule for (-> (-> L (-> L L)) L L L)
  case 173:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  if(a01->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a011 = a01->getChildren()[1];
  Expr& a010 = a01->getChildren()[0];
  Expr& a00 = a0->getChildren()[0];
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a0->getKind()==Kind::FUNCTION_TYPE && a01->getKind()==Kind::FUNCTION_TYPE && a010==a011 && a00==a011 && a1==a011 && a2==a011))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a011;
  // construct return type
  return _p1;
  }
  break;
  // type rule for (-> (-> L (-> L L)) L L L)
  case 184:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  if(a01->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a011 = a01->getChildren()[1];
  Expr& a010 = a01->getChildren()[0];
  Expr& a00 = a0->getChildren()[0];
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a0->getKind()==Kind::FUNCTION_TYPE && a01->getKind()==Kind::FUNCTION_TYPE && a010==a011 && a00==a011 && a1==a011 && a2==a011))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a011;
  // construct return type
  return _p1;
  }
  break;
  // type rule for (-> (-> L (-> L L)) L L L L)
  case 193:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  if(a01->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a011 = a01->getChildren()[1];
  Expr& a010 = a01->getChildren()[0];
  Expr& a00 = a0->getChildren()[0];
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  // check requirements
  if (!(a0->getKind()==Kind::FUNCTION_TYPE && a01->getKind()==Kind::FUNCTION_TYPE && a010==a011 && a00==a011 && a1==a011 && a2==a011 && a3==a011))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a011;
  // construct return type
  return _p1;
  }
  break;
  // type rule for (-> (-> L (-> L L)) L L L)
  case 203:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  if(a01->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a011 = a01->getChildren()[1];
  Expr& a010 = a01->getChildren()[0];
  Expr& a00 = a0->getChildren()[0];
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a0->getKind()==Kind::FUNCTION_TYPE && a01->getKind()==Kind::FUNCTION_TYPE && a010==a011 && a00==a011 && a1==a011 && a2==a011))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a011;
  // construct return type
  return _p1;
  }
  break;
  // type rule for (-> (-> L (-> L L)) I L L)
  case 215:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  if(a01->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a011 = a01->getChildren()[1];
  Expr& a010 = a01->getChildren()[0];
  Expr& a00 = a0->getChildren()[0];
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a0->getKind()==Kind::FUNCTION_TYPE && a01->getKind()==Kind::FUNCTION_TYPE && a010==a011 && a00==a011 && a2==a011))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a011;
  // construct return type
  return _p1;
  }
  break;
  // type rule for (-> Bool S S S)
  case 226:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a0==_e42 && a2==a1))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a1;
  // construct return type
  return _p1;
  }
  break;
  // type rule for (-> (-> L (-> L L)) L L Bool)
  case 235:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  if(a01->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a011 = a01->getChildren()[1];
  Expr& a010 = a01->getChildren()[0];
  Expr& a00 = a0->getChildren()[0];
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a0->getKind()==Kind::FUNCTION_TYPE && a01->getKind()==Kind::FUNCTION_TYPE && a010==a011 && a00==a011 && a1==a011 && a2==a011))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e42;
  }
  break;
  // type rule for (-> Bool Bool Bool)
  case 241:
  {
  const Expr& a0 = args[0];
  const Expr& a1 = args[1];
  // check requirements
  if (!(a0==_e42 && a1==_e42))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e42;
  }
  break;
  // type rule for (-> (Quote F) (Proof G) (Proof ((=> F) G)))
  case 300:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  const Expr& a1 = args[1];
  if(a1->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a10 = a1->getChildren()[0];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  // check requirements
  if (!(a1->getKind()==Kind::PROOF_TYPE))
  {
     return nullptr;
  }
  // assign variables
  _p2 = a0;
  _p1 = a10;
  // construct return type
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e60, _p2});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_p3, _p1});
  _p5 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p4});
  return _p5;
  }
  break;
  // type rule for (-> (Proof F) (Quote C) (Proof (run_process_scope F C)))
  case 324:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  const Expr& a1 = args[1];
  Expr _p3;
  Expr _p4;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a1;
  _p2 = a00;
  // construct return type
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e307, _p2, _p1}, _ctxTmp);
  _p3 = evaluate(_etmp, _ctxTmp);
  _p4 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p3});
  return _p4;
  }
  break;
  // type rule for (-> (Quote F) (Proof ((or F) ((or (not F)) (alf.nil Bool)))))
  case 334:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  Expr _p2;
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  // assign variables
  _p1 = a0;
  // construct return type
  _p2 = d_state.mkExprInternal(Kind::APPLY, {_e51, _p1});
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p2});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_p3, _e258});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p1});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_p5, _p4});
  _p7 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p6});
  return _p7;
  }
  break;
  // type rule for (-> Bool Bool Bool Bool Bool)
  case 340:
  {
  const Expr& a0 = args[0];
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  // check requirements
  if (!(a0==_e42 && a1==_e42 && a2==_e42 && a3==_e42))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e42;
  }
  break;
  // type rule for (-> (Proof C1) (Proof C2) (Quote pol) (Quote L) (Proof (resolve C1 C2 pol L)))
  case 366:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  Expr _p4;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  const Expr& a1 = args[1];
  if(a1->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a10 = a1->getChildren()[0];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  Expr _p5;
  Expr _p6;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE && a1->getKind()==Kind::PROOF_TYPE))
  {
     return nullptr;
  }
  // assign variables
  _p3 = a10;
  _p4 = a00;
  _p2 = a2;
  _p1 = a3;
  // construct return type
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e339, _p4, _p3, _p2, _p1}, _ctxTmp);
  _p5 = evaluate(_etmp, _ctxTmp);
  _p6 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p5});
  return _p6;
  }
  break;
  // type rule for (-> Bool Bool Bool Bool)
  case 368:
  {
  const Expr& a0 = args[0];
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a0==_e42 && a1==_e42 && a2==_e42))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e42;
  }
  break;
  // type rule for (-> (Proof Cs) (Quote args) (Proof (chainResolve Cs args)))
  case 389:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  const Expr& a1 = args[1];
  Expr _p3;
  Expr _p4;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE))
  {
     return nullptr;
  }
  // assign variables
  _p2 = a00;
  _p1 = a1;
  // construct return type
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e377, _p2, _p1}, _ctxTmp);
  _p3 = evaluate(_etmp, _ctxTmp);
  _p4 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p3});
  return _p4;
  }
  break;
  // type rule for (-> (Proof Cs) (Quote C) (Quote args) (Proof C))
  case 398:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  Expr _p4;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a1;
  // construct return type
  _p4 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p1});
  return _p4;
  }
  break;
  // type rule for (-> (Proof Cs) (Quote C) (Quote args) (Proof C))
  case 407:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  Expr _p4;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a1;
  // construct return type
  _p4 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p1});
  return _p4;
  }
  break;
  // type rule for (-> (Proof C) (Proof (reverseOr (factorLiterals (alf.nil Bool) C))))
  case 423:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  Expr _p2;
  Expr _p3;
  Expr _p4;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a00;
  // construct return type
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e408, _e258, _p1}, _ctxTmp);
  _p2 = evaluate(_etmp, _ctxTmp);
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e257, _p2}, _ctxTmp);
  _p3 = evaluate(_etmp, _ctxTmp);
  _p4 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p3});
  return _p4;
  }
  break;
  // type rule for (-> (Proof C1) (Quote C2) (Requires ((isPermutation C1 C2) true) (Proof C2)))
  case 442:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  const Expr& a1 = args[1];
  Expr _p3;
  Expr _p4;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE))
  {
     return nullptr;
  }
  // assign variables
  _p2 = a00;
  _p1 = a1;
  // handle requirement ((isPermutation C1 C2) true)
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e424, _p2, _p1}, _ctxTmp);
  _p3 = evaluate(_etmp, _ctxTmp);
  if (_p3!=_e227)
  {
    if (out) { (*out) << "Failed compiled requirement: " << _p3 << " == " << _e227; }
    return nullptr;
  }
  // construct return type
  _p4 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p1});
  return _p4;
  }
  break;
  // type rule for (-> (Proof F1) (Proof ((= F1) F2)) (Proof F2))
  case 451:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  const Expr& a1 = args[1];
  if(a1->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a10 = a1->getChildren()[0];
  if(a10->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a101 = a10->getChildren()[1];
  Expr& a100 = a10->getChildren()[0];
  if(a100->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a1001 = a100->getChildren()[1];
  Expr& a1000 = a100->getChildren()[0];
  Expr _p3;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE && a1->getKind()==Kind::PROOF_TYPE && a10->getKind()==Kind::APPLY && a100->getKind()==Kind::APPLY && a1001==a00 && a1000==_e62))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a101;
  // construct return type
  _p3 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p1});
  return _p3;
  }
  break;
  // type rule for (-> (Proof F1) (Proof ((=> F1) F2)) (Proof F2))
  case 460:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  const Expr& a1 = args[1];
  if(a1->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a10 = a1->getChildren()[0];
  if(a10->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a101 = a10->getChildren()[1];
  Expr& a100 = a10->getChildren()[0];
  if(a100->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a1001 = a100->getChildren()[1];
  Expr& a1000 = a100->getChildren()[0];
  Expr _p3;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE && a1->getKind()==Kind::PROOF_TYPE && a10->getKind()==Kind::APPLY && a100->getKind()==Kind::APPLY && a1001==a00 && a1000==_e60))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a101;
  // construct return type
  _p3 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p1});
  return _p3;
  }
  break;
  // type rule for (-> (Proof (not (not F))) (Proof F))
  case 467:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  if(a001->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a0011 = a001->getChildren()[1];
  Expr& a0010 = a001->getChildren()[0];
  Expr& a000 = a00->getChildren()[0];
  Expr _p2;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE && a00->getKind()==Kind::APPLY && a001->getKind()==Kind::APPLY && a0010==_e51 && a000==_e51))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a0011;
  // construct return type
  _p2 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p1});
  return _p2;
  }
  break;
  // type rule for (-> (Proof F) (Proof (not F)) (Proof false))
  case 474:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  const Expr& a1 = args[1];
  if(a1->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a10 = a1->getChildren()[0];
  if(a10->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a101 = a10->getChildren()[1];
  Expr& a100 = a10->getChildren()[0];
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE && a1->getKind()==Kind::PROOF_TYPE && a10->getKind()==Kind::APPLY && a101==a00 && a100==_e51))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e469;
  }
  break;
  // type rule for (-> (Proof Fs) (Quote i) (Proof (at and i Fs)))
  case 482:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  const Expr& a1 = args[1];
  Expr _p3;
  Expr _p4;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a00;
  _p2 = a1;
  // construct return type
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e210, _e59, _p2, _p1}, _ctxTmp);
  _p3 = evaluate(_etmp, _ctxTmp);
  _p4 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p3});
  return _p4;
  }
  break;
  // type rule for (-> (Proof F) (Proof Fs) (Proof (appendAnd F Fs)))
  case 490:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  const Expr& a1 = args[1];
  if(a1->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a10 = a1->getChildren()[0];
  Expr _p3;
  Expr _p4;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE && a1->getKind()==Kind::PROOF_TYPE))
  {
     return nullptr;
  }
  // assign variables
  _p2 = a00;
  _p1 = a10;
  // construct return type
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e271, _p2, _p1}, _ctxTmp);
  _p3 = evaluate(_etmp, _ctxTmp);
  _p4 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p3});
  return _p4;
  }
  break;
  // type rule for (-> (Proof F1) (Proof F2) (Proof ((and F1) ((and F2) (alf.nil Bool)))))
  case 501:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  const Expr& a1 = args[1];
  if(a1->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a10 = a1->getChildren()[0];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE && a1->getKind()==Kind::PROOF_TYPE))
  {
     return nullptr;
  }
  // assign variables
  _p2 = a00;
  _p1 = a10;
  // construct return type
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e59, _p1});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_p3, _e258});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_e59, _p2});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_p5, _p4});
  _p7 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p6});
  return _p7;
  }
  break;
  // type rule for (-> (Proof (not Fs)) (Quote i) (Proof (not (at or i Fs))))
  case 511:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  const Expr& a1 = args[1];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE && a00->getKind()==Kind::APPLY && a000==_e51))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a001;
  _p2 = a1;
  // construct return type
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e210, _e57, _p2, _p1}, _ctxTmp);
  _p3 = evaluate(_etmp, _ctxTmp);
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_e51, _p3});
  _p5 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p4});
  return _p5;
  }
  break;
  // type rule for (-> (Proof ((=> F1) F2)) (Proof ((or (not F1)) ((or F2) (alf.nil Bool)))))
  case 524:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  if(a000->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a0001 = a000->getChildren()[1];
  Expr& a0000 = a000->getChildren()[0];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE && a00->getKind()==Kind::APPLY && a000->getKind()==Kind::APPLY && a0000==_e60))
  {
     return nullptr;
  }
  // assign variables
  _p2 = a0001;
  _p1 = a001;
  // construct return type
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p1});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_p3, _e258});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_e51, _p2});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p5});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_p6, _p4});
  _p8 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p7});
  return _p8;
  }
  break;
  // type rule for (-> (Proof (not ((=> F1) F2))) (Proof F1))
  case 533:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  if(a001->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a0011 = a001->getChildren()[1];
  Expr& a0010 = a001->getChildren()[0];
  if(a0010->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a00101 = a0010->getChildren()[1];
  Expr& a00100 = a0010->getChildren()[0];
  Expr& a000 = a00->getChildren()[0];
  Expr _p3;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE && a00->getKind()==Kind::APPLY && a001->getKind()==Kind::APPLY && a0010->getKind()==Kind::APPLY && a00100==_e60 && a000==_e51))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a00101;
  // construct return type
  _p3 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p1});
  return _p3;
  }
  break;
  // type rule for (-> (Proof (not ((=> F1) F2))) (Proof (not F2)))
  case 543:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  if(a001->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a0011 = a001->getChildren()[1];
  Expr& a0010 = a001->getChildren()[0];
  if(a0010->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a00101 = a0010->getChildren()[1];
  Expr& a00100 = a0010->getChildren()[0];
  Expr& a000 = a00->getChildren()[0];
  Expr _p3;
  Expr _p4;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE && a00->getKind()==Kind::APPLY && a001->getKind()==Kind::APPLY && a0010->getKind()==Kind::APPLY && a00100==_e60 && a000==_e51))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a0011;
  // construct return type
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e51, _p1});
  _p4 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p3});
  return _p4;
  }
  break;
  // type rule for (-> (Proof ((= F1) F2)) (Proof ((or (not F1)) ((or F2) (alf.nil Bool)))))
  case 556:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  if(a000->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a0001 = a000->getChildren()[1];
  Expr& a0000 = a000->getChildren()[0];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE && a00->getKind()==Kind::APPLY && a000->getKind()==Kind::APPLY && a0000==_e62))
  {
     return nullptr;
  }
  // assign variables
  _p2 = a0001;
  _p1 = a001;
  // construct return type
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p1});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_p3, _e258});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_e51, _p2});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p5});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_p6, _p4});
  _p8 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p7});
  return _p8;
  }
  break;
  // type rule for (-> (Proof ((= F1) F2)) (Proof ((or F1) ((or (not F2)) (alf.nil Bool)))))
  case 569:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  if(a000->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a0001 = a000->getChildren()[1];
  Expr& a0000 = a000->getChildren()[0];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE && a00->getKind()==Kind::APPLY && a000->getKind()==Kind::APPLY && a0000==_e62))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a001;
  _p2 = a0001;
  // construct return type
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e51, _p1});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p3});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_p4, _e258});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p2});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_p6, _p5});
  _p8 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p7});
  return _p8;
  }
  break;
  // type rule for (-> (Proof (not ((= F1) F2))) (Proof ((or F1) ((or F2) (alf.nil Bool)))))
  case 582:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  if(a001->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a0011 = a001->getChildren()[1];
  Expr& a0010 = a001->getChildren()[0];
  if(a0010->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a00101 = a0010->getChildren()[1];
  Expr& a00100 = a0010->getChildren()[0];
  Expr& a000 = a00->getChildren()[0];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE && a00->getKind()==Kind::APPLY && a001->getKind()==Kind::APPLY && a0010->getKind()==Kind::APPLY && a00100==_e62 && a000==_e51))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a0011;
  _p2 = a00101;
  // construct return type
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p1});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_p3, _e258});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p2});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_p5, _p4});
  _p7 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p6});
  return _p7;
  }
  break;
  // type rule for (-> (Proof (not ((= F1) F2))) (Proof ((or (not F1)) ((or (not F2)) (alf.nil Bool)))))
  case 597:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  if(a001->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a0011 = a001->getChildren()[1];
  Expr& a0010 = a001->getChildren()[0];
  if(a0010->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a00101 = a0010->getChildren()[1];
  Expr& a00100 = a0010->getChildren()[0];
  Expr& a000 = a00->getChildren()[0];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE && a00->getKind()==Kind::APPLY && a001->getKind()==Kind::APPLY && a0010->getKind()==Kind::APPLY && a00100==_e62 && a000==_e51))
  {
     return nullptr;
  }
  // assign variables
  _p2 = a00101;
  _p1 = a0011;
  // construct return type
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e51, _p1});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p3});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_p4, _e258});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_e51, _p2});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p6});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_p7, _p5});
  _p9 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p8});
  return _p9;
  }
  break;
  // type rule for (-> (Proof ((xor F1) F2)) (Proof ((or F1) ((or F2) (alf.nil Bool)))))
  case 609:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  if(a000->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a0001 = a000->getChildren()[1];
  Expr& a0000 = a000->getChildren()[0];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE && a00->getKind()==Kind::APPLY && a000->getKind()==Kind::APPLY && a0000==_e61))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a001;
  _p2 = a0001;
  // construct return type
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p1});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_p3, _e258});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p2});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_p5, _p4});
  _p7 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p6});
  return _p7;
  }
  break;
  // type rule for (-> (Proof ((xor F1) F2)) (Proof ((or (not F1)) ((or (not F2)) (alf.nil Bool)))))
  case 623:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  if(a000->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a0001 = a000->getChildren()[1];
  Expr& a0000 = a000->getChildren()[0];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE && a00->getKind()==Kind::APPLY && a000->getKind()==Kind::APPLY && a0000==_e61))
  {
     return nullptr;
  }
  // assign variables
  _p2 = a0001;
  _p1 = a001;
  // construct return type
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e51, _p1});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p3});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_p4, _e258});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_e51, _p2});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p6});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_p7, _p5});
  _p9 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p8});
  return _p9;
  }
  break;
  // type rule for (-> (Proof (not ((xor F1) F2))) (Proof ((or F1) ((or (not F2)) (alf.nil Bool)))))
  case 637:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  if(a001->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a0011 = a001->getChildren()[1];
  Expr& a0010 = a001->getChildren()[0];
  if(a0010->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a00101 = a0010->getChildren()[1];
  Expr& a00100 = a0010->getChildren()[0];
  Expr& a000 = a00->getChildren()[0];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE && a00->getKind()==Kind::APPLY && a001->getKind()==Kind::APPLY && a0010->getKind()==Kind::APPLY && a00100==_e61 && a000==_e51))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a0011;
  _p2 = a00101;
  // construct return type
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e51, _p1});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p3});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_p4, _e258});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p2});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_p6, _p5});
  _p8 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p7});
  return _p8;
  }
  break;
  // type rule for (-> (Proof (not ((xor F1) F2))) (Proof ((or (not F1)) ((or F2) (alf.nil Bool)))))
  case 651:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  if(a001->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a0011 = a001->getChildren()[1];
  Expr& a0010 = a001->getChildren()[0];
  if(a0010->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a00101 = a0010->getChildren()[1];
  Expr& a00100 = a0010->getChildren()[0];
  Expr& a000 = a00->getChildren()[0];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE && a00->getKind()==Kind::APPLY && a001->getKind()==Kind::APPLY && a0010->getKind()==Kind::APPLY && a00100==_e61 && a000==_e51))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a0011;
  _p2 = a00101;
  // construct return type
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p1});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_p3, _e258});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_e51, _p2});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p5});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_p6, _p4});
  _p8 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p7});
  return _p8;
  }
  break;
  // type rule for (-> (Proof (((ite C) F1) F2)) (Proof ((or (not C)) ((or F1) (alf.nil Bool)))))
  case 666:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  if(a000->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a0001 = a000->getChildren()[1];
  Expr& a0000 = a000->getChildren()[0];
  if(a0000->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a00001 = a0000->getChildren()[1];
  Expr& a00000 = a0000->getChildren()[0];
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE && a00->getKind()==Kind::APPLY && a000->getKind()==Kind::APPLY && a0000->getKind()==Kind::APPLY && a00000==_e46))
  {
     return nullptr;
  }
  // assign variables
  _p2 = a00001;
  _p1 = a0001;
  // construct return type
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p1});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_p4, _e258});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_e51, _p2});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p6});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_p7, _p5});
  _p9 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p8});
  return _p9;
  }
  break;
  // type rule for (-> (Proof (((ite C) F1) F2)) (Proof ((or C) ((or F2) (alf.nil Bool)))))
  case 680:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  if(a000->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a0001 = a000->getChildren()[1];
  Expr& a0000 = a000->getChildren()[0];
  if(a0000->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a00001 = a0000->getChildren()[1];
  Expr& a00000 = a0000->getChildren()[0];
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE && a00->getKind()==Kind::APPLY && a000->getKind()==Kind::APPLY && a0000->getKind()==Kind::APPLY && a00000==_e46))
  {
     return nullptr;
  }
  // assign variables
  _p2 = a00001;
  _p1 = a001;
  // construct return type
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p1});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_p4, _e258});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p2});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_p6, _p5});
  _p8 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p7});
  return _p8;
  }
  break;
  // type rule for (-> (Proof (not (((ite C) F1) F2))) (Proof ((or (not C)) ((or (not F1)) (alf.nil Bool)))))
  case 697:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  if(a001->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a0011 = a001->getChildren()[1];
  Expr& a0010 = a001->getChildren()[0];
  if(a0010->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a00101 = a0010->getChildren()[1];
  Expr& a00100 = a0010->getChildren()[0];
  if(a00100->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001001 = a00100->getChildren()[1];
  Expr& a001000 = a00100->getChildren()[0];
  Expr& a000 = a00->getChildren()[0];
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  Expr _p10;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE && a00->getKind()==Kind::APPLY && a001->getKind()==Kind::APPLY && a0010->getKind()==Kind::APPLY && a00100->getKind()==Kind::APPLY && a001000==_e46 && a000==_e51))
  {
     return nullptr;
  }
  // assign variables
  _p2 = a001001;
  _p1 = a00101;
  // construct return type
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_e51, _p1});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p4});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_p5, _e258});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_e51, _p2});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p7});
  _p9 = d_state.mkExprInternal(Kind::APPLY, {_p8, _p6});
  _p10 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p9});
  return _p10;
  }
  break;
  // type rule for (-> (Proof (not (((ite C) F1) F2))) (Proof ((or C) ((or (not F2)) (alf.nil Bool)))))
  case 713:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  if(a001->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a0011 = a001->getChildren()[1];
  Expr& a0010 = a001->getChildren()[0];
  if(a0010->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a00101 = a0010->getChildren()[1];
  Expr& a00100 = a0010->getChildren()[0];
  if(a00100->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001001 = a00100->getChildren()[1];
  Expr& a001000 = a00100->getChildren()[0];
  Expr& a000 = a00->getChildren()[0];
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE && a00->getKind()==Kind::APPLY && a001->getKind()==Kind::APPLY && a0010->getKind()==Kind::APPLY && a00100->getKind()==Kind::APPLY && a001000==_e46 && a000==_e51))
  {
     return nullptr;
  }
  // assign variables
  _p2 = a001001;
  _p1 = a0011;
  // construct return type
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_e51, _p1});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p4});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_p5, _e258});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p2});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_p7, _p6});
  _p9 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p8});
  return _p9;
  }
  break;
  // type rule for (-> (Proof (not F)) (Proof (lowerNotAnd F)))
  case 726:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  Expr _p2;
  Expr _p3;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE && a00->getKind()==Kind::APPLY && a000==_e51))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a001;
  // construct return type
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e714, _p1}, _ctxTmp);
  _p2 = evaluate(_etmp, _ctxTmp);
  _p3 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p2});
  return _p3;
  }
  break;
  // type rule for (-> (Quote Fs) (Quote i) (Proof ((or (not Fs)) ((or (at and i Fs)) (alf.nil Bool)))))
  case 739:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  const Expr& a1 = args[1];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  // assign variables
  _p1 = a0;
  _p2 = a1;
  // construct return type
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e210, _e59, _p2, _p1}, _ctxTmp);
  _p3 = evaluate(_etmp, _ctxTmp);
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p3});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_p4, _e258});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_e51, _p1});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p6});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_p7, _p5});
  _p9 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p8});
  return _p9;
  }
  break;
  // type rule for (-> (Quote Fs) (Proof (appendOr Fs (lowerNotAnd Fs))))
  case 746:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  Expr _p2;
  Expr _p3;
  Expr _p4;
  // assign variables
  _p1 = a0;
  // construct return type
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e714, _p1}, _ctxTmp);
  _p2 = evaluate(_etmp, _ctxTmp);
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e245, _p1, _p2}, _ctxTmp);
  _p3 = evaluate(_etmp, _ctxTmp);
  _p4 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p3});
  return _p4;
  }
  break;
  // type rule for (-> (Quote Fs) (Proof (appendOr (not Fs) Fs)))
  case 753:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  Expr _p2;
  Expr _p3;
  Expr _p4;
  // assign variables
  _p1 = a0;
  // construct return type
  _p2 = d_state.mkExprInternal(Kind::APPLY, {_e51, _p1});
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e245, _p2, _p1}, _ctxTmp);
  _p3 = evaluate(_etmp, _ctxTmp);
  _p4 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p3});
  return _p4;
  }
  break;
  // type rule for (-> (Quote Fs) (Quote i) (Proof (concatOr Fs (appendOr (not (at or i Fs)) (alf.nil Bool)))))
  case 764:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  const Expr& a1 = args[1];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  // assign variables
  _p1 = a0;
  _p2 = a1;
  // construct return type
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e210, _e57, _p2, _p1}, _ctxTmp);
  _p3 = evaluate(_etmp, _ctxTmp);
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_e51, _p3});
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e245, _p4, _e258}, _ctxTmp);
  _p5 = evaluate(_etmp, _ctxTmp);
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e249, _p1, _p5}, _ctxTmp);
  _p6 = evaluate(_etmp, _ctxTmp);
  _p7 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p6});
  return _p7;
  }
  break;
  // type rule for (let ((_v0 ((=> F1) F2))) (-> (Quote _v0) (Proof ((or (not _v0)) ((or (not F1)) ((or F2) (alf.nil Bool)))))))
  case 780:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  Expr _p10;
  Expr _p11;
  Expr _p12;
  Expr _p13;
  // check requirements
  if (!(a0->getKind()==Kind::APPLY && a00->getKind()==Kind::APPLY && a000==_e60))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a01;
  _p2 = a001;
  // construct return type
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p1});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_p3, _e258});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_e51, _p2});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p5});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_p6, _p4});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_e60, _p2});
  _p9 = d_state.mkExprInternal(Kind::APPLY, {_p8, _p1});
  _p10 = d_state.mkExprInternal(Kind::APPLY, {_e51, _p9});
  _p11 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p10});
  _p12 = d_state.mkExprInternal(Kind::APPLY, {_p11, _p7});
  _p13 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p12});
  return _p13;
  }
  break;
  // type rule for (let ((_v0 ((=> F1) F2))) (-> (Quote _v0) (Proof ((or _v0) ((or F1) (alf.nil Bool))))))
  case 792:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  // check requirements
  if (!(a0->getKind()==Kind::APPLY && a00->getKind()==Kind::APPLY && a000==_e60))
  {
     return nullptr;
  }
  // assign variables
  _p2 = a01;
  _p1 = a001;
  // construct return type
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p1});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_p3, _e258});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_e60, _p1});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_p5, _p2});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p6});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_p7, _p4});
  _p9 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p8});
  return _p9;
  }
  break;
  // type rule for (let ((_v0 ((=> F1) F2))) (-> (Quote _v0) (Proof ((or _v0) ((or (not F2)) (alf.nil Bool))))))
  case 805:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  Expr _p10;
  // check requirements
  if (!(a0->getKind()==Kind::APPLY && a00->getKind()==Kind::APPLY && a000==_e60))
  {
     return nullptr;
  }
  // assign variables
  _p2 = a001;
  _p1 = a01;
  // construct return type
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e51, _p1});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p3});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_p4, _e258});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_e60, _p2});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_p6, _p1});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p7});
  _p9 = d_state.mkExprInternal(Kind::APPLY, {_p8, _p5});
  _p10 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p9});
  return _p10;
  }
  break;
  // type rule for (let ((_v0 ((= F1) F2))) (-> (Quote _v0) (Proof ((or (not _v0)) ((or (not F1)) ((or F2) (alf.nil Bool)))))))
  case 821:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  Expr _p10;
  Expr _p11;
  Expr _p12;
  Expr _p13;
  // check requirements
  if (!(a0->getKind()==Kind::APPLY && a00->getKind()==Kind::APPLY && a000==_e62))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a01;
  _p2 = a001;
  // construct return type
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p1});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_p3, _e258});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_e51, _p2});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p5});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_p6, _p4});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_e62, _p2});
  _p9 = d_state.mkExprInternal(Kind::APPLY, {_p8, _p1});
  _p10 = d_state.mkExprInternal(Kind::APPLY, {_e51, _p9});
  _p11 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p10});
  _p12 = d_state.mkExprInternal(Kind::APPLY, {_p11, _p7});
  _p13 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p12});
  return _p13;
  }
  break;
  // type rule for (let ((_v0 ((= F1) F2))) (-> (Quote _v0) (Proof ((or (not _v0)) ((or F1) ((or (not F2)) (alf.nil Bool)))))))
  case 837:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  Expr _p10;
  Expr _p11;
  Expr _p12;
  Expr _p13;
  // check requirements
  if (!(a0->getKind()==Kind::APPLY && a00->getKind()==Kind::APPLY && a000==_e62))
  {
     return nullptr;
  }
  // assign variables
  _p2 = a001;
  _p1 = a01;
  // construct return type
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e51, _p1});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p3});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_p4, _e258});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p2});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_p6, _p5});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_e62, _p2});
  _p9 = d_state.mkExprInternal(Kind::APPLY, {_p8, _p1});
  _p10 = d_state.mkExprInternal(Kind::APPLY, {_e51, _p9});
  _p11 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p10});
  _p12 = d_state.mkExprInternal(Kind::APPLY, {_p11, _p7});
  _p13 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p12});
  return _p13;
  }
  break;
  // type rule for (let ((_v0 ((= F1) F2))) (-> (Quote _v0) (Proof ((or _v0) ((or F1) ((or F2) (alf.nil Bool)))))))
  case 851:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  Expr _p10;
  Expr _p11;
  // check requirements
  if (!(a0->getKind()==Kind::APPLY && a00->getKind()==Kind::APPLY && a000==_e62))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a01;
  _p2 = a001;
  // construct return type
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p1});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_p3, _e258});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p2});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_p5, _p4});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_e62, _p2});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_p7, _p1});
  _p9 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p8});
  _p10 = d_state.mkExprInternal(Kind::APPLY, {_p9, _p6});
  _p11 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p10});
  return _p11;
  }
  break;
  // type rule for (let ((_v0 ((= F1) F2))) (-> (Quote _v0) (Proof ((or _v0) ((or (not F1)) ((or (not F2)) (alf.nil Bool)))))))
  case 867:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  Expr _p10;
  Expr _p11;
  Expr _p12;
  Expr _p13;
  // check requirements
  if (!(a0->getKind()==Kind::APPLY && a00->getKind()==Kind::APPLY && a000==_e62))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a01;
  _p2 = a001;
  // construct return type
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e51, _p1});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p3});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_p4, _e258});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_e51, _p2});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p6});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_p7, _p5});
  _p9 = d_state.mkExprInternal(Kind::APPLY, {_e62, _p2});
  _p10 = d_state.mkExprInternal(Kind::APPLY, {_p9, _p1});
  _p11 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p10});
  _p12 = d_state.mkExprInternal(Kind::APPLY, {_p11, _p8});
  _p13 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p12});
  return _p13;
  }
  break;
  // type rule for (let ((_v0 ((xor F1) F2))) (-> (Quote _v0) (Proof ((or (not _v0)) ((or F1) ((or F2) (alf.nil Bool)))))))
  case 882:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  Expr _p10;
  Expr _p11;
  Expr _p12;
  // check requirements
  if (!(a0->getKind()==Kind::APPLY && a00->getKind()==Kind::APPLY && a000==_e61))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a01;
  _p2 = a001;
  // construct return type
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p1});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_p3, _e258});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p2});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_p5, _p4});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_e61, _p2});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_p7, _p1});
  _p9 = d_state.mkExprInternal(Kind::APPLY, {_e51, _p8});
  _p10 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p9});
  _p11 = d_state.mkExprInternal(Kind::APPLY, {_p10, _p6});
  _p12 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p11});
  return _p12;
  }
  break;
  // type rule for (let ((_v0 ((xor F1) F2))) (-> (Quote _v0) (Proof ((or (not _v0)) ((or (not F1)) ((or (not F2)) (alf.nil Bool)))))))
  case 899:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  Expr _p10;
  Expr _p11;
  Expr _p12;
  Expr _p13;
  Expr _p14;
  // check requirements
  if (!(a0->getKind()==Kind::APPLY && a00->getKind()==Kind::APPLY && a000==_e61))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a01;
  _p2 = a001;
  // construct return type
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e51, _p1});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p3});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_p4, _e258});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_e51, _p2});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p6});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_p7, _p5});
  _p9 = d_state.mkExprInternal(Kind::APPLY, {_e61, _p2});
  _p10 = d_state.mkExprInternal(Kind::APPLY, {_p9, _p1});
  _p11 = d_state.mkExprInternal(Kind::APPLY, {_e51, _p10});
  _p12 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p11});
  _p13 = d_state.mkExprInternal(Kind::APPLY, {_p12, _p8});
  _p14 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p13});
  return _p14;
  }
  break;
  // type rule for (let ((_v0 ((xor F1) F2))) (-> (Quote _v0) (Proof ((or _v0) ((or (not F1)) ((or F2) (alf.nil Bool)))))))
  case 914:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  Expr _p10;
  Expr _p11;
  Expr _p12;
  // check requirements
  if (!(a0->getKind()==Kind::APPLY && a00->getKind()==Kind::APPLY && a000==_e61))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a01;
  _p2 = a001;
  // construct return type
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p1});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_p3, _e258});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_e51, _p2});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p5});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_p6, _p4});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_e61, _p2});
  _p9 = d_state.mkExprInternal(Kind::APPLY, {_p8, _p1});
  _p10 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p9});
  _p11 = d_state.mkExprInternal(Kind::APPLY, {_p10, _p7});
  _p12 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p11});
  return _p12;
  }
  break;
  // type rule for (let ((_v0 ((xor F1) F2))) (-> (Quote _v0) (Proof ((or _v0) ((or F1) ((or (not F2)) (alf.nil Bool)))))))
  case 929:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  Expr _p10;
  Expr _p11;
  Expr _p12;
  // check requirements
  if (!(a0->getKind()==Kind::APPLY && a00->getKind()==Kind::APPLY && a000==_e61))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a01;
  _p2 = a001;
  // construct return type
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e51, _p1});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p3});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_p4, _e258});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p2});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_p6, _p5});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_e61, _p2});
  _p9 = d_state.mkExprInternal(Kind::APPLY, {_p8, _p1});
  _p10 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p9});
  _p11 = d_state.mkExprInternal(Kind::APPLY, {_p10, _p7});
  _p12 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p11});
  return _p12;
  }
  break;
  // type rule for (let ((_v0 (((ite C) F1) F2))) (-> (Quote _v0) (Proof ((or (not _v0)) ((or (not C)) ((or F1) (alf.nil Bool)))))))
  case 947:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  if(a000->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a0001 = a000->getChildren()[1];
  Expr& a0000 = a000->getChildren()[0];
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  Expr _p10;
  Expr _p11;
  Expr _p12;
  Expr _p13;
  Expr _p14;
  Expr _p15;
  // check requirements
  if (!(a0->getKind()==Kind::APPLY && a00->getKind()==Kind::APPLY && a000->getKind()==Kind::APPLY && a0000==_e46))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a001;
  _p2 = a0001;
  _p3 = a01;
  // construct return type
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p1});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_p4, _e258});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_e51, _p2});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p6});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_p7, _p5});
  _p9 = d_state.mkExprInternal(Kind::APPLY, {_e46, _p2});
  _p10 = d_state.mkExprInternal(Kind::APPLY, {_p9, _p1});
  _p11 = d_state.mkExprInternal(Kind::APPLY, {_p10, _p3});
  _p12 = d_state.mkExprInternal(Kind::APPLY, {_e51, _p11});
  _p13 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p12});
  _p14 = d_state.mkExprInternal(Kind::APPLY, {_p13, _p8});
  _p15 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p14});
  return _p15;
  }
  break;
  // type rule for (let ((_v0 (((ite C) F1) F2))) (-> (Quote _v0) (Proof ((or (not _v0)) ((or C) ((or F2) (alf.nil Bool)))))))
  case 964:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  if(a000->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a0001 = a000->getChildren()[1];
  Expr& a0000 = a000->getChildren()[0];
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  Expr _p10;
  Expr _p11;
  Expr _p12;
  Expr _p13;
  Expr _p14;
  // check requirements
  if (!(a0->getKind()==Kind::APPLY && a00->getKind()==Kind::APPLY && a000->getKind()==Kind::APPLY && a0000==_e46))
  {
     return nullptr;
  }
  // assign variables
  _p2 = a0001;
  _p3 = a001;
  _p1 = a01;
  // construct return type
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p1});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_p4, _e258});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p2});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_p6, _p5});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_e46, _p2});
  _p9 = d_state.mkExprInternal(Kind::APPLY, {_p8, _p3});
  _p10 = d_state.mkExprInternal(Kind::APPLY, {_p9, _p1});
  _p11 = d_state.mkExprInternal(Kind::APPLY, {_e51, _p10});
  _p12 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p11});
  _p13 = d_state.mkExprInternal(Kind::APPLY, {_p12, _p7});
  _p14 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p13});
  return _p14;
  }
  break;
  // type rule for (let ((_v0 (((ite C) F1) F2))) (-> (Quote _v0) (Proof ((or (not _v0)) ((or F1) ((or F2) (alf.nil Bool)))))))
  case 981:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  if(a000->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a0001 = a000->getChildren()[1];
  Expr& a0000 = a000->getChildren()[0];
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  Expr _p10;
  Expr _p11;
  Expr _p12;
  Expr _p13;
  Expr _p14;
  // check requirements
  if (!(a0->getKind()==Kind::APPLY && a00->getKind()==Kind::APPLY && a000->getKind()==Kind::APPLY && a0000==_e46))
  {
     return nullptr;
  }
  // assign variables
  _p3 = a0001;
  _p2 = a001;
  _p1 = a01;
  // construct return type
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p1});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_p4, _e258});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p2});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_p6, _p5});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_e46, _p3});
  _p9 = d_state.mkExprInternal(Kind::APPLY, {_p8, _p2});
  _p10 = d_state.mkExprInternal(Kind::APPLY, {_p9, _p1});
  _p11 = d_state.mkExprInternal(Kind::APPLY, {_e51, _p10});
  _p12 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p11});
  _p13 = d_state.mkExprInternal(Kind::APPLY, {_p12, _p7});
  _p14 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p13});
  return _p14;
  }
  break;
  // type rule for (let ((_v0 (((ite C) F1) F2))) (-> (Quote _v0) (Proof ((or _v0) ((or (not C)) ((or (not F1)) (alf.nil Bool)))))))
  case 999:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  if(a000->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a0001 = a000->getChildren()[1];
  Expr& a0000 = a000->getChildren()[0];
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  Expr _p10;
  Expr _p11;
  Expr _p12;
  Expr _p13;
  Expr _p14;
  Expr _p15;
  // check requirements
  if (!(a0->getKind()==Kind::APPLY && a00->getKind()==Kind::APPLY && a000->getKind()==Kind::APPLY && a0000==_e46))
  {
     return nullptr;
  }
  // assign variables
  _p2 = a0001;
  _p1 = a001;
  _p3 = a01;
  // construct return type
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_e51, _p1});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p4});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_p5, _e258});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_e51, _p2});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p7});
  _p9 = d_state.mkExprInternal(Kind::APPLY, {_p8, _p6});
  _p10 = d_state.mkExprInternal(Kind::APPLY, {_e46, _p2});
  _p11 = d_state.mkExprInternal(Kind::APPLY, {_p10, _p1});
  _p12 = d_state.mkExprInternal(Kind::APPLY, {_p11, _p3});
  _p13 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p12});
  _p14 = d_state.mkExprInternal(Kind::APPLY, {_p13, _p9});
  _p15 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p14});
  return _p15;
  }
  break;
  // type rule for (let ((_v0 (((ite C) F1) F2))) (-> (Quote _v0) (Proof ((or _v0) ((or C) ((or (not F2)) (alf.nil Bool)))))))
  case 1016:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  if(a000->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a0001 = a000->getChildren()[1];
  Expr& a0000 = a000->getChildren()[0];
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  Expr _p10;
  Expr _p11;
  Expr _p12;
  Expr _p13;
  Expr _p14;
  // check requirements
  if (!(a0->getKind()==Kind::APPLY && a00->getKind()==Kind::APPLY && a000->getKind()==Kind::APPLY && a0000==_e46))
  {
     return nullptr;
  }
  // assign variables
  _p2 = a0001;
  _p3 = a001;
  _p1 = a01;
  // construct return type
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_e51, _p1});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p4});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_p5, _e258});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p2});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_p7, _p6});
  _p9 = d_state.mkExprInternal(Kind::APPLY, {_e46, _p2});
  _p10 = d_state.mkExprInternal(Kind::APPLY, {_p9, _p3});
  _p11 = d_state.mkExprInternal(Kind::APPLY, {_p10, _p1});
  _p12 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p11});
  _p13 = d_state.mkExprInternal(Kind::APPLY, {_p12, _p8});
  _p14 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p13});
  return _p14;
  }
  break;
  // type rule for (let ((_v0 (((ite C) F1) F2))) (-> (Quote _v0) (Proof ((or _v0) ((or (not F1)) ((or (not F2)) (alf.nil Bool)))))))
  case 1034:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  if(a000->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a0001 = a000->getChildren()[1];
  Expr& a0000 = a000->getChildren()[0];
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  Expr _p10;
  Expr _p11;
  Expr _p12;
  Expr _p13;
  Expr _p14;
  Expr _p15;
  // check requirements
  if (!(a0->getKind()==Kind::APPLY && a00->getKind()==Kind::APPLY && a000->getKind()==Kind::APPLY && a0000==_e46))
  {
     return nullptr;
  }
  // assign variables
  _p3 = a0001;
  _p2 = a001;
  _p1 = a01;
  // construct return type
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_e51, _p1});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p4});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_p5, _e258});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_e51, _p2});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p7});
  _p9 = d_state.mkExprInternal(Kind::APPLY, {_p8, _p6});
  _p10 = d_state.mkExprInternal(Kind::APPLY, {_e46, _p3});
  _p11 = d_state.mkExprInternal(Kind::APPLY, {_p10, _p2});
  _p12 = d_state.mkExprInternal(Kind::APPLY, {_p11, _p1});
  _p13 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p12});
  _p14 = d_state.mkExprInternal(Kind::APPLY, {_p13, _p9});
  _p15 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p14});
  return _p15;
  }
  break;
  // type rule for (-> (Proof Fs) (Proof false))
  case 1038:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e469;
  }
  break;
  // type rule for (-> (Quote t) (Proof ((= t) t)))
  case 1046:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  Expr _p2;
  Expr _p3;
  Expr _p4;
  // assign variables
  _p1 = a0;
  // construct return type
  _p2 = d_state.mkExprInternal(Kind::APPLY, {_e62, _p1});
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_p2, _p1});
  _p4 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p3});
  return _p4;
  }
  break;
  // type rule for (-> (Proof F) (Proof (flipEq F)))
  case 1059:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  Expr _p2;
  Expr _p3;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a00;
  // construct return type
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e1047, _p1}, _ctxTmp);
  _p2 = evaluate(_etmp, _ctxTmp);
  _p3 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p2});
  return _p3;
  }
  break;
  // type rule for (let ((_v0 (= t1))) (-> (Proof (_v0 t2)) (Proof ((= t2) t3)) (Proof (_v0 t3))))
  case 1073:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  if(a000->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a0001 = a000->getChildren()[1];
  Expr& a0000 = a000->getChildren()[0];
  const Expr& a1 = args[1];
  if(a1->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a10 = a1->getChildren()[0];
  if(a10->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a101 = a10->getChildren()[1];
  Expr& a100 = a10->getChildren()[0];
  if(a100->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a1001 = a100->getChildren()[1];
  Expr& a1000 = a100->getChildren()[0];
  Expr _p4;
  Expr _p5;
  Expr _p6;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE && a00->getKind()==Kind::APPLY && a000->getKind()==Kind::APPLY && a0000==_e62 && a1->getKind()==Kind::PROOF_TYPE && a10->getKind()==Kind::APPLY && a100->getKind()==Kind::APPLY && a1001==a001 && a1000==_e62))
  {
     return nullptr;
  }
  // assign variables
  _p2 = a0001;
  _p1 = a101;
  // construct return type
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_e62, _p2});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_p4, _p1});
  _p6 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p5});
  return _p6;
  }
  break;
  // type rule for (-> (Proof ((= t1) t2)) (Quote f) (Proof ((= (f t1)) (f t2))))
  case 1090:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  if(a000->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a0001 = a000->getChildren()[1];
  Expr& a0000 = a000->getChildren()[0];
  const Expr& a1 = args[1];
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE && a00->getKind()==Kind::APPLY && a000->getKind()==Kind::APPLY && a0000==_e62))
  {
     return nullptr;
  }
  // assign variables
  _p2 = a1;
  _p3 = a0001;
  _p1 = a001;
  // construct return type
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_p2, _p1});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_p2, _p3});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_e62, _p5});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_p6, _p4});
  _p8 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p7});
  return _p8;
  }
  break;
  // type rule for (-> (Proof F) (Proof ((= F) true)))
  case 1097:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  Expr _p2;
  Expr _p3;
  Expr _p4;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a00;
  // construct return type
  _p2 = d_state.mkExprInternal(Kind::APPLY, {_e62, _p1});
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_p2, _e227});
  _p4 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p3});
  return _p4;
  }
  break;
  // type rule for (-> (Proof ((= F) true)) (Proof F))
  case 1104:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  if(a000->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a0001 = a000->getChildren()[1];
  Expr& a0000 = a000->getChildren()[0];
  Expr _p2;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE && a00->getKind()==Kind::APPLY && a001==_e227 && a000->getKind()==Kind::APPLY && a0000==_e62))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a0001;
  // construct return type
  _p2 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p1});
  return _p2;
  }
  break;
  // type rule for (-> (Proof (not F)) (Proof ((= F) false)))
  case 1112:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  Expr _p2;
  Expr _p3;
  Expr _p4;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE && a00->getKind()==Kind::APPLY && a000==_e51))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a001;
  // construct return type
  _p2 = d_state.mkExprInternal(Kind::APPLY, {_e62, _p1});
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_p2, _e229});
  _p4 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p3});
  return _p4;
  }
  break;
  // type rule for (-> (Proof ((= F) false)) (Proof (not F)))
  case 1120:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  if(a000->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a0001 = a000->getChildren()[1];
  Expr& a0000 = a000->getChildren()[0];
  Expr _p2;
  Expr _p3;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE && a00->getKind()==Kind::APPLY && a001==_e229 && a000->getKind()==Kind::APPLY && a0000==_e62))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a0001;
  // construct return type
  _p2 = d_state.mkExprInternal(Kind::APPLY, {_e51, _p1});
  _p3 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p2});
  return _p3;
  }
  break;
  // type rule for (-> (Proof ((= f) g)) (Proof ((= t1) t2)) (Proof ((= (f t1)) (g t2))))
  case 1140:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  Expr _p4;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  if(a000->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a0001 = a000->getChildren()[1];
  Expr& a0000 = a000->getChildren()[0];
  const Expr& a1 = args[1];
  if(a1->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a10 = a1->getChildren()[0];
  if(a10->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a101 = a10->getChildren()[1];
  Expr& a100 = a10->getChildren()[0];
  if(a100->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a1001 = a100->getChildren()[1];
  Expr& a1000 = a100->getChildren()[0];
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE && a00->getKind()==Kind::APPLY && a000->getKind()==Kind::APPLY && a0000==_e62 && a1->getKind()==Kind::PROOF_TYPE && a10->getKind()==Kind::APPLY && a100->getKind()==Kind::APPLY && a1000==_e62))
  {
     return nullptr;
  }
  // assign variables
  _p4 = a0001;
  _p1 = a101;
  _p2 = a001;
  _p3 = a1001;
  // construct return type
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_p2, _p1});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_p4, _p3});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_e62, _p6});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_p7, _p5});
  _p9 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p8});
  return _p9;
  }
  break;
  // type rule for (-> (Quote t) (Quote t_encoded) (Proof ((= t) t_encoded)))
  case 1150:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  const Expr& a1 = args[1];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  // assign variables
  _p2 = a0;
  _p1 = a1;
  // construct return type
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e62, _p2});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_p3, _p1});
  _p5 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p4});
  return _p5;
  }
  break;
  default: break;
  }
  return nullptr;
}

Expr TypeChecker::run_evaluate(Expr& e, Ctx& ctx)
{
  Ctx::iterator itc;
  std::map<ExprValue*, size_t>::iterator itr = _runId.find(e.get());
  switch(itr->second)
  {
  // evaluation for ((cons c) xs)
  case 145:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  Expr _p4;
  Expr _p5;
  itc = ctx.find(_e141);
  _p1 = (itc==ctx.end() ? _e141 : itc->second);
  itc = ctx.find(_e142);
  _p2 = (itc==ctx.end() ? _e142 : itc->second);
  itc = ctx.find(_e143);
  _p3 = (itc==ctx.end() ? _e143 : itc->second);
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_p3, _p2});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_p4, _p1});
  return _p5;
  }
  break;
  // evaluation for (alf.nil L)
  case 162:
  {
  Expr _p1;
  Expr _p2;
  itc = ctx.find(_e158);
  _p1 = (itc==ctx.end() ? _e158 : itc->second);
  _p2 = d_state.mkNil(_p1);
  return _p2;
  }
  break;
  // evaluation for (alf.add i -1)
  case 220:
  {
  Expr _p1;
  Expr _p2;
  itc = ctx.find(_e219);
  _p1 = (itc==ctx.end() ? _e219 : itc->second);
  _p2 = evaluateLiteralOp(Kind::EVAL_ADD, {_p1, _e218});
  return _p2;
  }
  break;
  // evaluation for (not L)
  case 342:
  {
  Expr _p1;
  Expr _p2;
  itc = ctx.find(_e341);
  _p1 = (itc==ctx.end() ? _e341 : itc->second);
  _p2 = d_state.mkExprInternal(Kind::APPLY, {_e51, _p1});
  return _p2;
  }
  break;
  // evaluation for ((or l2) l2s)
  case 428:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  Expr _p4;
  itc = ctx.find(_e425);
  _p1 = (itc==ctx.end() ? _e425 : itc->second);
  itc = ctx.find(_e426);
  _p2 = (itc==ctx.end() ? _e426 : itc->second);
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e57, _p2});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_p3, _p1});
  return _p4;
  }
  break;
  // evaluation for (not l)
  case 716:
  {
  Expr _p1;
  Expr _p2;
  itc = ctx.find(_e715);
  _p1 = (itc==ctx.end() ? _e715 : itc->second);
  _p2 = d_state.mkExprInternal(Kind::APPLY, {_e51, _p1});
  return _p2;
  }
  break;
  // evaluation for ((= t2) t1)
  case 1052:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  Expr _p4;
  itc = ctx.find(_e1048);
  _p1 = (itc==ctx.end() ? _e1048 : itc->second);
  itc = ctx.find(_e1050);
  _p2 = (itc==ctx.end() ? _e1050 : itc->second);
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e62, _p2});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_p3, _p1});
  return _p4;
  }
  break;
  // evaluation for (not ((= t2) t1))
  case 1053:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  Expr _p4;
  Expr _p5;
  itc = ctx.find(_e1048);
  _p1 = (itc==ctx.end() ? _e1048 : itc->second);
  itc = ctx.find(_e1050);
  _p2 = (itc==ctx.end() ? _e1050 : itc->second);
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e62, _p2});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_p3, _p1});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_e51, _p4});
  return _p5;
  }
  break;
  default: break;
  }
  return nullptr;
}

Expr TypeChecker::run_evaluateProgram(const std::vector<Expr>& args, Ctx& ctx)
{
  std::map<ExprValue*, size_t>::iterator itr = _runId.find(args[0].get());
  switch(itr->second)
  {
  case 130:
  {
     size_t _i=0;
     while (_i<2)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (ifEqThenElse x x t1 t2)
       case 1:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  const Expr& a4 = args[4];
  // check requirements
  if (!(a2==a1))
  {
     break;
  }
  // construct the context
  ctx[_e134] = a3;
  // return t1
  return _e134;
       }
       break;
       // matching for arguments of (ifEqThenElse x cmp t1 t2)
       case 2:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  const Expr& a4 = args[4];
  // check requirements
  // construct the context
  ctx[_e135] = a4;
  // return t2
  return _e135;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 136:
  {
     size_t _i=0;
     while (_i<1)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (append cons c xs)
       case 1:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  // check requirements
  // construct the context
  ctx[_e143] = a1;
  ctx[_e142] = a2;
  ctx[_e141] = a3;
  // return ((cons c) xs)
  return _e145;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 146:
  {
     size_t _i=0;
     while (_i<2)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (concat cons (alf.nil L) ys)
       case 1:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  if(a2->getNumChildren()!=1)
  {
    break;
  }
  Expr& a20 = a2->getChildren()[0];
  const Expr& a3 = args[3];
  // check requirements
  if (!(a2->getKind()==Kind::NIL))
  {
     break;
  }
  // construct the context
  ctx[_e151] = a3;
  // return ys
  return _e151;
       }
       break;
       // matching for arguments of (concat cons ((cons x) xs) ys)
       case 2:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  if(a2->getNumChildren()!=2)
  {
    break;
  }
  Expr& a21 = a2->getChildren()[1];
  Expr& a20 = a2->getChildren()[0];
  if(a20->getNumChildren()!=2)
  {
    break;
  }
  Expr& a201 = a20->getChildren()[1];
  Expr& a200 = a20->getChildren()[0];
  const Expr& a3 = args[3];
  // check requirements
  if (!(a2->getKind()==Kind::APPLY && a20->getKind()==Kind::APPLY && a200==a1))
  {
     break;
  }
  // construct the context
  ctx[_e155] = a201;
  ctx[_e153] = a1;
  ctx[_e152] = a21;
  ctx[_e151] = a3;
  // return (append cons x (concat cons xs ys))
  return _e156;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 157:
  {
     size_t _i=0;
     while (_i<3)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (remove cons c (alf.nil L))
       case 1:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  if(a3->getNumChildren()!=1)
  {
    break;
  }
  Expr& a30 = a3->getChildren()[0];
  // check requirements
  if (!(a3->getKind()==Kind::NIL))
  {
     break;
  }
  // construct the context
  ctx[_e158] = a30;
  // return (alf.nil L)
  return _e162;
       }
       break;
       // matching for arguments of (remove cons c ((cons c) xs))
       case 2:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  if(a3->getNumChildren()!=2)
  {
    break;
  }
  Expr& a31 = a3->getChildren()[1];
  Expr& a30 = a3->getChildren()[0];
  if(a30->getNumChildren()!=2)
  {
    break;
  }
  Expr& a301 = a30->getChildren()[1];
  Expr& a300 = a30->getChildren()[0];
  // check requirements
  if (!(a3->getKind()==Kind::APPLY && a30->getKind()==Kind::APPLY && a301==a2 && a300==a1))
  {
     break;
  }
  // construct the context
  ctx[_e163] = a31;
  // return xs
  return _e163;
       }
       break;
       // matching for arguments of (remove cons c ((cons y) xs))
       case 3:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  if(a3->getNumChildren()!=2)
  {
    break;
  }
  Expr& a31 = a3->getChildren()[1];
  Expr& a30 = a3->getChildren()[0];
  if(a30->getNumChildren()!=2)
  {
    break;
  }
  Expr& a301 = a30->getChildren()[1];
  Expr& a300 = a30->getChildren()[0];
  // check requirements
  if (!(a3->getKind()==Kind::APPLY && a30->getKind()==Kind::APPLY && a300==a1))
  {
     break;
  }
  // construct the context
  ctx[_e164] = a2;
  ctx[_e167] = a301;
  ctx[_e165] = a1;
  ctx[_e163] = a31;
  // return (append cons y (remove cons c xs))
  return _e168;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 169:
  {
     size_t _i=0;
     while (_i<2)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (reverseRec cons (alf.nil L) l)
       case 1:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  if(a2->getNumChildren()!=1)
  {
    break;
  }
  Expr& a20 = a2->getChildren()[0];
  const Expr& a3 = args[3];
  // check requirements
  if (!(a2->getKind()==Kind::NIL))
  {
     break;
  }
  // construct the context
  ctx[_e174] = a3;
  // return l
  return _e174;
       }
       break;
       // matching for arguments of (reverseRec cons ((cons x) xs) l)
       case 2:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  if(a2->getNumChildren()!=2)
  {
    break;
  }
  Expr& a21 = a2->getChildren()[1];
  Expr& a20 = a2->getChildren()[0];
  if(a20->getNumChildren()!=2)
  {
    break;
  }
  Expr& a201 = a20->getChildren()[1];
  Expr& a200 = a20->getChildren()[0];
  const Expr& a3 = args[3];
  // check requirements
  if (!(a2->getKind()==Kind::APPLY && a20->getKind()==Kind::APPLY && a200==a1))
  {
     break;
  }
  // construct the context
  ctx[_e175] = a201;
  ctx[_e178] = a21;
  ctx[_e174] = a3;
  ctx[_e176] = a1;
  // return (reverseRec cons xs (append cons x l))
  return _e179;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 180:
  {
     size_t _i=0;
     while (_i<1)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (reverse cons nil xs)
       case 1:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  // check requirements
  // construct the context
  ctx[_e187] = a1;
  ctx[_e185] = a2;
  ctx[_e186] = a3;
  // return (reverseRec cons xs nil)
  return _e188;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 189:
  {
     size_t _i=0;
     while (_i<4)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (naryElim cons nil c nil)
       case 1:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  const Expr& a4 = args[4];
  // check requirements
  if (!(a4==a2))
  {
     break;
  }
  // construct the context
  ctx[_e194] = a3;
  // return c
  return _e194;
       }
       break;
       // matching for arguments of (naryElim cons nil c ((cons x) nil))
       case 2:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  const Expr& a4 = args[4];
  if(a4->getNumChildren()!=2)
  {
    break;
  }
  Expr& a41 = a4->getChildren()[1];
  Expr& a40 = a4->getChildren()[0];
  if(a40->getNumChildren()!=2)
  {
    break;
  }
  Expr& a401 = a40->getChildren()[1];
  Expr& a400 = a40->getChildren()[0];
  // check requirements
  if (!(a4->getKind()==Kind::APPLY && a41==a2 && a40->getKind()==Kind::APPLY && a400==a1))
  {
     break;
  }
  // construct the context
  ctx[_e195] = a401;
  // return x
  return _e195;
       }
       break;
       // matching for arguments of (naryElim cons nil c ((cons x) xs))
       case 3:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  const Expr& a4 = args[4];
  if(a4->getNumChildren()!=2)
  {
    break;
  }
  Expr& a41 = a4->getChildren()[1];
  Expr& a40 = a4->getChildren()[0];
  if(a40->getNumChildren()!=2)
  {
    break;
  }
  Expr& a401 = a40->getChildren()[1];
  Expr& a400 = a40->getChildren()[0];
  // check requirements
  if (!(a4->getKind()==Kind::APPLY && a40->getKind()==Kind::APPLY && a400==a1))
  {
     break;
  }
  // construct the context
  ctx[_e197] = a1;
  ctx[_e196] = a41;
  ctx[_e195] = a401;
  // return (append cons x xs)
  return _e198;
       }
       break;
       // matching for arguments of (naryElim cons nil c xs)
       case 4:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  const Expr& a4 = args[4];
  // check requirements
  // construct the context
  ctx[_e196] = a4;
  // return xs
  return _e196;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 199:
  {
     size_t _i=0;
     while (_i<2)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (naryIntro cons nil ((cons x) xs))
       case 1:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  if(a3->getNumChildren()!=2)
  {
    break;
  }
  Expr& a31 = a3->getChildren()[1];
  Expr& a30 = a3->getChildren()[0];
  if(a30->getNumChildren()!=2)
  {
    break;
  }
  Expr& a301 = a30->getChildren()[1];
  Expr& a300 = a30->getChildren()[0];
  // check requirements
  if (!(a3->getKind()==Kind::APPLY && a30->getKind()==Kind::APPLY && a300==a1))
  {
     break;
  }
  // construct the context
  ctx[_e205] = a301;
  ctx[_e204] = a31;
  ctx[_e206] = a1;
  // return (append cons x xs)
  return _e207;
       }
       break;
       // matching for arguments of (naryIntro cons nil x)
       case 2:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  // check requirements
  // construct the context
  ctx[_e208] = a2;
  ctx[_e205] = a3;
  ctx[_e206] = a1;
  // return (append cons x nil)
  return _e209;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 210:
  {
     size_t _i=0;
     while (_i<2)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (at cons 0 ((cons x) xs))
       case 1:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  if(a3->getNumChildren()!=2)
  {
    break;
  }
  Expr& a31 = a3->getChildren()[1];
  Expr& a30 = a3->getChildren()[0];
  if(a30->getNumChildren()!=2)
  {
    break;
  }
  Expr& a301 = a30->getChildren()[1];
  Expr& a300 = a30->getChildren()[0];
  // check requirements
  if (!(a2==_e216 && a3->getKind()==Kind::APPLY && a30->getKind()==Kind::APPLY && a300==a1))
  {
     break;
  }
  // construct the context
  ctx[_e217] = a301;
  // return x
  return _e217;
       }
       break;
       // matching for arguments of (at cons i ((cons x) xs))
       case 2:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  if(a3->getNumChildren()!=2)
  {
    break;
  }
  Expr& a31 = a3->getChildren()[1];
  Expr& a30 = a3->getChildren()[0];
  if(a30->getNumChildren()!=2)
  {
    break;
  }
  Expr& a301 = a30->getChildren()[1];
  Expr& a300 = a30->getChildren()[0];
  // check requirements
  if (!(a3->getKind()==Kind::APPLY && a30->getKind()==Kind::APPLY && a300==a1))
  {
     break;
  }
  // construct the context
  ctx[_e222] = a1;
  ctx[_e221] = a31;
  ctx[_e219] = a2;
  // return (at cons (alf.add i -1) xs)
  return _e223;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 224:
  {
     size_t _i=0;
     while (_i<2)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (ifThenElse true t1 t2)
       case 1:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  // check requirements
  if (!(a1==_e227))
  {
     break;
  }
  // construct the context
  ctx[_e228] = a2;
  // return t1
  return _e228;
       }
       break;
       // matching for arguments of (ifThenElse false t1 t2)
       case 2:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  // check requirements
  if (!(a1==_e229))
  {
     break;
  }
  // construct the context
  ctx[_e230] = a3;
  // return t2
  return _e230;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 231:
  {
     size_t _i=0;
     while (_i<3)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (inList cons c (alf.nil L))
       case 1:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  if(a3->getNumChildren()!=1)
  {
    break;
  }
  Expr& a30 = a3->getChildren()[0];
  // check requirements
  if (!(a3->getKind()==Kind::NIL))
  {
     break;
  }
  // return false
  return _e229;
  // construct the context
  // return false
  return _e229;
       }
       break;
       // matching for arguments of (inList cons c ((cons c) xs))
       case 2:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  if(a3->getNumChildren()!=2)
  {
    break;
  }
  Expr& a31 = a3->getChildren()[1];
  Expr& a30 = a3->getChildren()[0];
  if(a30->getNumChildren()!=2)
  {
    break;
  }
  Expr& a301 = a30->getChildren()[1];
  Expr& a300 = a30->getChildren()[0];
  // check requirements
  if (!(a3->getKind()==Kind::APPLY && a30->getKind()==Kind::APPLY && a301==a2 && a300==a1))
  {
     break;
  }
  // return true
  return _e227;
  // construct the context
  // return true
  return _e227;
       }
       break;
       // matching for arguments of (inList cons c ((cons x) xs))
       case 3:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  if(a3->getNumChildren()!=2)
  {
    break;
  }
  Expr& a31 = a3->getChildren()[1];
  Expr& a30 = a3->getChildren()[0];
  if(a30->getNumChildren()!=2)
  {
    break;
  }
  Expr& a301 = a30->getChildren()[1];
  Expr& a300 = a30->getChildren()[0];
  // check requirements
  if (!(a3->getKind()==Kind::APPLY && a30->getKind()==Kind::APPLY && a300==a1))
  {
     break;
  }
  // construct the context
  ctx[_e238] = a1;
  ctx[_e237] = a2;
  ctx[_e236] = a31;
  // return (inList cons c xs)
  return _e239;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 240:
  {
     size_t _i=0;
     while (_i<1)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (inListOr c l)
       case 1:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  // construct the context
  ctx[_e243] = a1;
  ctx[_e242] = a2;
  // return (inList or c l)
  return _e244;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 245:
  {
     size_t _i=0;
     while (_i<1)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (appendOr c l)
       case 1:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  // construct the context
  ctx[_e247] = a1;
  ctx[_e246] = a2;
  // return (append or c l)
  return _e248;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 249:
  {
     size_t _i=0;
     while (_i<1)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (concatOr l1 l2)
       case 1:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  // construct the context
  ctx[_e251] = a1;
  ctx[_e250] = a2;
  // return (concat or l1 l2)
  return _e252;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 253:
  {
     size_t _i=0;
     while (_i<1)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (removeOr c l)
       case 1:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  // construct the context
  ctx[_e255] = a1;
  ctx[_e254] = a2;
  // return (remove or c l)
  return _e256;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 257:
  {
     size_t _i=0;
     while (_i<1)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (reverseOr xs)
       case 1:
       {
  const Expr& a1 = args[1];
  // check requirements
  // construct the context
  ctx[_e259] = a1;
  // return (reverse or (alf.nil Bool) xs)
  return _e260;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 261:
  {
     size_t _i=0;
     while (_i<1)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (naryElimOr t)
       case 1:
       {
  const Expr& a1 = args[1];
  // check requirements
  // construct the context
  ctx[_e262] = a1;
  // return (naryElim or (alf.nil Bool) false t)
  return _e263;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 264:
  {
     size_t _i=0;
     while (_i<1)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (naryIntroOr t)
       case 1:
       {
  const Expr& a1 = args[1];
  // check requirements
  // construct the context
  ctx[_e265] = a1;
  // return (naryIntro or (alf.nil Bool) t)
  return _e266;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 267:
  {
     size_t _i=0;
     while (_i<1)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (inListAnd c l)
       case 1:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  // construct the context
  ctx[_e269] = a1;
  ctx[_e268] = a2;
  // return (inList and c l)
  return _e270;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 271:
  {
     size_t _i=0;
     while (_i<1)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (appendAnd c l)
       case 1:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  // construct the context
  ctx[_e273] = a1;
  ctx[_e272] = a2;
  // return (append and c l)
  return _e274;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 275:
  {
     size_t _i=0;
     while (_i<1)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (concatAnd l1 l2)
       case 1:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  // construct the context
  ctx[_e277] = a1;
  ctx[_e276] = a2;
  // return (concat and l1 l2)
  return _e278;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 279:
  {
     size_t _i=0;
     while (_i<1)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (removeAnd c l)
       case 1:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  // construct the context
  ctx[_e281] = a1;
  ctx[_e280] = a2;
  // return (remove and c l)
  return _e282;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 283:
  {
     size_t _i=0;
     while (_i<1)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (reverseAnd xs)
       case 1:
       {
  const Expr& a1 = args[1];
  // check requirements
  // construct the context
  ctx[_e284] = a1;
  // return (reverse and (alf.nil Bool) xs)
  return _e285;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 286:
  {
     size_t _i=0;
     while (_i<1)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (naryElimAnd t)
       case 1:
       {
  const Expr& a1 = args[1];
  // check requirements
  // construct the context
  ctx[_e287] = a1;
  // return (naryElim and (alf.nil Bool) true t)
  return _e288;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 289:
  {
     size_t _i=0;
     while (_i<1)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (naryIntroAnd t)
       case 1:
       {
  const Expr& a1 = args[1];
  // check requirements
  // construct the context
  ctx[_e290] = a1;
  // return (naryIntro and (alf.nil Bool) t)
  return _e291;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 301:
  {
     size_t _i=0;
     while (_i<2)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (extract_antec C C)
       case 1:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a2==a1))
  {
     break;
  }
  // return (alf.nil Bool)
  return _e258;
  // construct the context
  // return (alf.nil Bool)
  return _e258;
       }
       break;
       // matching for arguments of (extract_antec ((=> F1) F2) C)
       case 2:
       {
  const Expr& a1 = args[1];
  if(a1->getNumChildren()!=2)
  {
    break;
  }
  Expr& a11 = a1->getChildren()[1];
  Expr& a10 = a1->getChildren()[0];
  if(a10->getNumChildren()!=2)
  {
    break;
  }
  Expr& a101 = a10->getChildren()[1];
  Expr& a100 = a10->getChildren()[0];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a1->getKind()==Kind::APPLY && a10->getKind()==Kind::APPLY && a100==_e60))
  {
     break;
  }
  // construct the context
  ctx[_e305] = a101;
  ctx[_e303] = a11;
  ctx[_e302] = a2;
  // return (appendAnd F1 (extract_antec F2 C))
  return _e306;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 307:
  {
     size_t _i=0;
     while (_i<2)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (run_process_scope F false)
       case 1:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a2==_e229))
  {
     break;
  }
  // construct the context
  ctx[_e308] = a1;
  // return (not (naryElimAnd (extract_antec F false)))
  return _e311;
       }
       break;
       // matching for arguments of (run_process_scope F C)
       case 2:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  // construct the context
  ctx[_e308] = a1;
  ctx[_e312] = a2;
  // return ((=> (naryElimAnd (extract_antec F C))) C)
  return _e316;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 335:
  {
     size_t _i=0;
     while (_i<2)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (removeSelf l l)
       case 1:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a2==a1))
  {
     break;
  }
  // return false
  return _e229;
  // construct the context
  // return false
  return _e229;
       }
       break;
       // matching for arguments of (removeSelf l C)
       case 2:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  // construct the context
  ctx[_e336] = a2;
  ctx[_e337] = a1;
  // return (removeOr l C)
  return _e338;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 339:
  {
     size_t _i=0;
     while (_i<2)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (resolve C1 C2 true L)
       case 1:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  const Expr& a4 = args[4];
  // check requirements
  if (!(a3==_e227))
  {
     break;
  }
  // construct the context
  ctx[_e346] = a1;
  ctx[_e343] = a2;
  ctx[_e341] = a4;
  // return (naryElimOr (concatOr (removeSelf L (naryIntroOr C1)) (removeSelf (not L) (naryIntroOr C2))))
  return _e350;
       }
       break;
       // matching for arguments of (resolve C1 C2 false L)
       case 2:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  const Expr& a4 = args[4];
  // check requirements
  if (!(a3==_e229))
  {
     break;
  }
  // construct the context
  ctx[_e346] = a1;
  ctx[_e343] = a2;
  ctx[_e341] = a4;
  // return (naryElimOr (concatOr (removeSelf (not L) (naryIntroOr C1)) (removeSelf L (naryIntroOr C2))))
  return _e354;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 367:
  {
     size_t _i=0;
     while (_i<2)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (let ((_v0 (alf.nil Bool))) (chainResolveRec C1 _v0 _v0))
       case 1:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  // check requirements
  if (!(a2==_e258 && a3==_e258))
  {
     break;
  }
  // construct the context
  ctx[_e369] = a1;
  // return C1
  return _e369;
       }
       break;
       // matching for arguments of (chainResolveRec C1 ((and C2) Cs) ((and pol) ((and L) args)))
       case 2:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  if(a2->getNumChildren()!=2)
  {
    break;
  }
  Expr& a21 = a2->getChildren()[1];
  Expr& a20 = a2->getChildren()[0];
  if(a20->getNumChildren()!=2)
  {
    break;
  }
  Expr& a201 = a20->getChildren()[1];
  Expr& a200 = a20->getChildren()[0];
  const Expr& a3 = args[3];
  if(a3->getNumChildren()!=2)
  {
    break;
  }
  Expr& a31 = a3->getChildren()[1];
  if(a31->getNumChildren()!=2)
  {
    break;
  }
  Expr& a311 = a31->getChildren()[1];
  Expr& a310 = a31->getChildren()[0];
  if(a310->getNumChildren()!=2)
  {
    break;
  }
  Expr& a3101 = a310->getChildren()[1];
  Expr& a3100 = a310->getChildren()[0];
  Expr& a30 = a3->getChildren()[0];
  if(a30->getNumChildren()!=2)
  {
    break;
  }
  Expr& a301 = a30->getChildren()[1];
  Expr& a300 = a30->getChildren()[0];
  // check requirements
  if (!(a2->getKind()==Kind::APPLY && a20->getKind()==Kind::APPLY && a200==_e59 && a3->getKind()==Kind::APPLY && a31->getKind()==Kind::APPLY && a310->getKind()==Kind::APPLY && a3100==_e59 && a30->getKind()==Kind::APPLY && a300==_e59))
  {
     break;
  }
  // construct the context
  ctx[_e369] = a1;
  ctx[_e374] = a201;
  ctx[_e371] = a21;
  ctx[_e373] = a301;
  ctx[_e370] = a311;
  ctx[_e372] = a3101;
  // return (chainResolveRec (resolve C1 C2 pol L) Cs args)
  return _e376;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 377:
  {
     size_t _i=0;
     while (_i<1)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (chainResolve ((and C1) Cs) args)
       case 1:
       {
  const Expr& a1 = args[1];
  if(a1->getNumChildren()!=2)
  {
    break;
  }
  Expr& a11 = a1->getChildren()[1];
  Expr& a10 = a1->getChildren()[0];
  if(a10->getNumChildren()!=2)
  {
    break;
  }
  Expr& a101 = a10->getChildren()[1];
  Expr& a100 = a10->getChildren()[0];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a1->getKind()==Kind::APPLY && a10->getKind()==Kind::APPLY && a100==_e59))
  {
     break;
  }
  // construct the context
  ctx[_e380] = a101;
  ctx[_e379] = a11;
  ctx[_e378] = a2;
  // return (chainResolveRec C1 Cs args)
  return _e381;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 408:
  {
     size_t _i=0;
     while (_i<2)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (factorLiterals xs (alf.nil Bool))
       case 1:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a2==_e258))
  {
     break;
  }
  // construct the context
  ctx[_e409] = a1;
  // return (naryElimOr xs)
  return _e410;
       }
       break;
       // matching for arguments of (factorLiterals xs ((or l) ls))
       case 2:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  if(a2->getNumChildren()!=2)
  {
    break;
  }
  Expr& a21 = a2->getChildren()[1];
  Expr& a20 = a2->getChildren()[0];
  if(a20->getNumChildren()!=2)
  {
    break;
  }
  Expr& a201 = a20->getChildren()[1];
  Expr& a200 = a20->getChildren()[0];
  // check requirements
  if (!(a2->getKind()==Kind::APPLY && a20->getKind()==Kind::APPLY && a200==_e57))
  {
     break;
  }
  // construct the context
  ctx[_e409] = a1;
  ctx[_e412] = a201;
  ctx[_e411] = a21;
  // return (factorLiterals (ifThenElse (inListOr l xs) xs (appendOr l xs)) ls)
  return _e416;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 424:
  {
     size_t _i=0;
     while (_i<3)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (isPermutation l1 l1)
       case 1:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a2==a1))
  {
     break;
  }
  // return true
  return _e227;
  // construct the context
  // return true
  return _e227;
       }
       break;
       // matching for arguments of (isPermutation (alf.nil Bool) l1)
       case 2:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a1==_e258))
  {
     break;
  }
  // return false
  return _e229;
  // construct the context
  // return false
  return _e229;
       }
       break;
       // matching for arguments of (isPermutation ((or l1) l1s) ((or l2) l2s))
       case 3:
       {
  const Expr& a1 = args[1];
  if(a1->getNumChildren()!=2)
  {
    break;
  }
  Expr& a11 = a1->getChildren()[1];
  Expr& a10 = a1->getChildren()[0];
  if(a10->getNumChildren()!=2)
  {
    break;
  }
  Expr& a101 = a10->getChildren()[1];
  Expr& a100 = a10->getChildren()[0];
  const Expr& a2 = args[2];
  if(a2->getNumChildren()!=2)
  {
    break;
  }
  Expr& a21 = a2->getChildren()[1];
  Expr& a20 = a2->getChildren()[0];
  if(a20->getNumChildren()!=2)
  {
    break;
  }
  Expr& a201 = a20->getChildren()[1];
  Expr& a200 = a20->getChildren()[0];
  // check requirements
  if (!(a1->getKind()==Kind::APPLY && a10->getKind()==Kind::APPLY && a100==_e57 && a2->getKind()==Kind::APPLY && a20->getKind()==Kind::APPLY && a200==_e57))
  {
     break;
  }
  // construct the context
  ctx[_e429] = a101;
  ctx[_e426] = a201;
  ctx[_e431] = a11;
  ctx[_e425] = a21;
  // return (isPermutation l1s (removeOr l1 ((or l2) l2s)))
  return _e432;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 714:
  {
     size_t _i=0;
     while (_i<2)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (lowerNotAnd (alf.nil Bool))
       case 1:
       {
  const Expr& a1 = args[1];
  // check requirements
  if (!(a1==_e258))
  {
     break;
  }
  // return (alf.nil Bool)
  return _e258;
  // construct the context
  // return (alf.nil Bool)
  return _e258;
       }
       break;
       // matching for arguments of (lowerNotAnd ((and l) ls))
       case 2:
       {
  const Expr& a1 = args[1];
  if(a1->getNumChildren()!=2)
  {
    break;
  }
  Expr& a11 = a1->getChildren()[1];
  Expr& a10 = a1->getChildren()[0];
  if(a10->getNumChildren()!=2)
  {
    break;
  }
  Expr& a101 = a10->getChildren()[1];
  Expr& a100 = a10->getChildren()[0];
  // check requirements
  if (!(a1->getKind()==Kind::APPLY && a10->getKind()==Kind::APPLY && a100==_e59))
  {
     break;
  }
  // construct the context
  ctx[_e715] = a101;
  ctx[_e717] = a11;
  // return (appendOr (not l) (lowerNotAnd ls))
  return _e719;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 1047:
  {
     size_t _i=0;
     while (_i<2)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (flipEq ((= t1) t2))
       case 1:
       {
  const Expr& a1 = args[1];
  if(a1->getNumChildren()!=2)
  {
    break;
  }
  Expr& a11 = a1->getChildren()[1];
  Expr& a10 = a1->getChildren()[0];
  if(a10->getNumChildren()!=2)
  {
    break;
  }
  Expr& a101 = a10->getChildren()[1];
  Expr& a100 = a10->getChildren()[0];
  // check requirements
  if (!(a1->getKind()==Kind::APPLY && a10->getKind()==Kind::APPLY && a100==_e62))
  {
     break;
  }
  // construct the context
  ctx[_e1048] = a101;
  ctx[_e1050] = a11;
  // return ((= t2) t1)
  return _e1052;
       }
       break;
       // matching for arguments of (flipEq (not ((= t1) t2)))
       case 2:
       {
  const Expr& a1 = args[1];
  if(a1->getNumChildren()!=2)
  {
    break;
  }
  Expr& a11 = a1->getChildren()[1];
  if(a11->getNumChildren()!=2)
  {
    break;
  }
  Expr& a111 = a11->getChildren()[1];
  Expr& a110 = a11->getChildren()[0];
  if(a110->getNumChildren()!=2)
  {
    break;
  }
  Expr& a1101 = a110->getChildren()[1];
  Expr& a1100 = a110->getChildren()[0];
  Expr& a10 = a1->getChildren()[0];
  // check requirements
  if (!(a1->getKind()==Kind::APPLY && a11->getKind()==Kind::APPLY && a110->getKind()==Kind::APPLY && a1100==_e62 && a10==_e51))
  {
     break;
  }
  // construct the context
  ctx[_e1048] = a1101;
  ctx[_e1050] = a111;
  // return (not ((= t2) t1))
  return _e1053;
       }
       break;
       default: break;
       }
     }
  }
  break;
  default: break;
  }
  return d_state.mkExprInternal(Kind::APPLY, args);
}

}

